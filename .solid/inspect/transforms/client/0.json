{
  "id": "/@solid-refresh",
  "deps": [],
  "plugins": [
    "solid",
    "vite:import-analysis"
  ],
  "transforms": [
    {
      "name": "solid",
      "result": "import { $DEVCOMP, createMemo, untrack, createSignal } from 'solid-js';\n\nfunction createProxy(source) {\n    return new Proxy(function hmrCompWrapper(props, ...rest) {\n        const s = source();\n        if (!s || $DEVCOMP in s) {\n            return createMemo(() => {\n                const c = source();\n                if (c) {\n                    return untrack(() => c(props));\n                }\n                return undefined;\n            });\n        }\n        // no $DEVCOMP means it did not go through devComponent so source() is a regular function, not a component\n        return s.call(this, props, ...rest);\n    }, {\n        get(_, property) {\n            return source()[property];\n        },\n        set(_, property, value) {\n            source()[property] = value;\n            return true;\n        },\n    });\n}\n\nfunction isListUpdated(a, b) {\n    if (a == null && b != null) {\n        return true;\n    }\n    if (a != null && b == null) {\n        return true;\n    }\n    if (a && b) {\n        if (a.length !== b.length) {\n            return true;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!Object.is(a[i], b[i])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfunction hot$1({ component: Comp, id, signature, dependencies }, hot) {\n    if (hot) {\n        const [comp, setComp] = createSignal(Comp);\n        const prev = hot.data;\n        // Check if there's previous data\n        if (prev && prev[id]) {\n            // Check if there's a new signature and dependency\n            // This is always new in standard HMR\n            if (signature && dependencies) {\n                // Check if signature changed\n                // or dependencies changed\n                if (prev[id].signature !== signature\n                    || isListUpdated(prev[id].dependencies, dependencies)) {\n                    // Remount\n                    prev[id].dependencies = dependencies;\n                    prev[id].signature = signature;\n                    prev[id].setComp(() => Comp);\n                }\n            }\n            else {\n                prev[id].setComp(() => Comp);\n            }\n        }\n        hot.dispose(data => {\n            data[id] = prev ? prev[id] : {\n                setComp,\n                signature,\n                dependencies,\n            };\n        });\n        hot.accept();\n        return createProxy(comp);\n    }\n    return Comp;\n}\n\nfunction hot({ component: Comp, id, signature, dependencies }, isHot) {\n    let Component = Comp;\n    function handler(newModule) {\n        const registration = newModule.$$registrations[id];\n        if (!registration) {\n            // For some reason, the registration was lost, invalidate\n            return true;\n        }\n        registration.component.setComp = Comp.setComp;\n        registration.component.signature = Comp.signature;\n        registration.component.dependencies = Comp.dependencies;\n        // Check if incoming module has signature\n        if (registration.signature && registration.dependencies) {\n            // Compare old signature and dependencies\n            if (registration.signature !== Comp.signature\n                || isListUpdated(registration.dependencies, Comp.dependencies)) {\n                // Remount\n                Comp.dependencies = registration.dependencies;\n                Comp.signature = registration.signature;\n                Comp.setComp(() => registration.component);\n            }\n        }\n        else {\n            // No granular update, remount\n            Comp.setComp(() => registration.component);\n        }\n        registration.component.signature = Comp.signature;\n        registration.component.dependencies = Comp.dependencies;\n        return false;\n    }\n    if (isHot) {\n        const [comp, setComp] = createSignal(Comp);\n        Comp.setComp = setComp;\n        Comp.dependencies = dependencies;\n        Comp.signature = signature;\n        Component = createProxy(comp);\n    }\n    return { Component, handler };\n}\n\nexport { hot as esm, hot$1 as standard };\n",
      "start": 1681505639032,
      "end": 1681505639032
    },
    {
      "name": "vite:import-analysis",
      "result": "import { $DEVCOMP, createMemo, untrack, createSignal } from '/node_modules/.vite/deps/solid-js.js?v=6ed96d96';\n\nfunction createProxy(source) {\n    return new Proxy(function hmrCompWrapper(props, ...rest) {\n        const s = source();\n        if (!s || $DEVCOMP in s) {\n            return createMemo(() => {\n                const c = source();\n                if (c) {\n                    return untrack(() => c(props));\n                }\n                return undefined;\n            });\n        }\n        // no $DEVCOMP means it did not go through devComponent so source() is a regular function, not a component\n        return s.call(this, props, ...rest);\n    }, {\n        get(_, property) {\n            return source()[property];\n        },\n        set(_, property, value) {\n            source()[property] = value;\n            return true;\n        },\n    });\n}\n\nfunction isListUpdated(a, b) {\n    if (a == null && b != null) {\n        return true;\n    }\n    if (a != null && b == null) {\n        return true;\n    }\n    if (a && b) {\n        if (a.length !== b.length) {\n            return true;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!Object.is(a[i], b[i])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfunction hot$1({ component: Comp, id, signature, dependencies }, hot) {\n    if (hot) {\n        const [comp, setComp] = createSignal(Comp);\n        const prev = hot.data;\n        // Check if there's previous data\n        if (prev && prev[id]) {\n            // Check if there's a new signature and dependency\n            // This is always new in standard HMR\n            if (signature && dependencies) {\n                // Check if signature changed\n                // or dependencies changed\n                if (prev[id].signature !== signature\n                    || isListUpdated(prev[id].dependencies, dependencies)) {\n                    // Remount\n                    prev[id].dependencies = dependencies;\n                    prev[id].signature = signature;\n                    prev[id].setComp(() => Comp);\n                }\n            }\n            else {\n                prev[id].setComp(() => Comp);\n            }\n        }\n        hot.dispose(data => {\n            data[id] = prev ? prev[id] : {\n                setComp,\n                signature,\n                dependencies,\n            };\n        });\n        hot.accept();\n        return createProxy(comp);\n    }\n    return Comp;\n}\n\nfunction hot({ component: Comp, id, signature, dependencies }, isHot) {\n    let Component = Comp;\n    function handler(newModule) {\n        const registration = newModule.$$registrations[id];\n        if (!registration) {\n            // For some reason, the registration was lost, invalidate\n            return true;\n        }\n        registration.component.setComp = Comp.setComp;\n        registration.component.signature = Comp.signature;\n        registration.component.dependencies = Comp.dependencies;\n        // Check if incoming module has signature\n        if (registration.signature && registration.dependencies) {\n            // Compare old signature and dependencies\n            if (registration.signature !== Comp.signature\n                || isListUpdated(registration.dependencies, Comp.dependencies)) {\n                // Remount\n                Comp.dependencies = registration.dependencies;\n                Comp.signature = registration.signature;\n                Comp.setComp(() => registration.component);\n            }\n        }\n        else {\n            // No granular update, remount\n            Comp.setComp(() => registration.component);\n        }\n        registration.component.signature = Comp.signature;\n        registration.component.dependencies = Comp.dependencies;\n        return false;\n    }\n    if (isHot) {\n        const [comp, setComp] = createSignal(Comp);\n        Comp.setComp = setComp;\n        Comp.dependencies = dependencies;\n        Comp.signature = signature;\n        Component = createProxy(comp);\n    }\n    return { Component, handler };\n}\n\nexport { hot as esm, hot$1 as standard };\n",
      "start": 1681505639033,
      "end": 1681505639034
    }
  ],
  "virtual": true
}