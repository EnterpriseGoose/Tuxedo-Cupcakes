{
  "id": "/project/Tuxedo-Cupcakes/node_modules/.vite/deps/@supabase_supabase-js.js?v=d142efd7",
  "deps": [],
  "plugins": [
    "vite:optimized-deps",
    "vite:import-analysis"
  ],
  "transforms": [
    {
      "name": "vite:optimized-deps",
      "result": "import {\n  require_browser_ponyfill\n} from \"./chunk-ZVVIQIK2.js\";\nimport {\n  __commonJS,\n  __toESM\n} from \"./chunk-TWLJ45QX.js\";\n\n// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/global.js\nvar require_global = __commonJS({\n  \"node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/global.js\"(exports, module) {\n    var naiveFallback = function() {\n      if (typeof self === \"object\" && self)\n        return self;\n      if (typeof window === \"object\" && window)\n        return window;\n      throw new Error(\"Unable to resolve global `this`\");\n    };\n    module.exports = function() {\n      if (this)\n        return this;\n      if (typeof globalThis === \"object\" && globalThis)\n        return globalThis;\n      try {\n        Object.defineProperty(Object.prototype, \"__global__\", {\n          get: function() {\n            return this;\n          },\n          configurable: true\n        });\n      } catch (error) {\n        return naiveFallback();\n      }\n      try {\n        if (!__global__)\n          return naiveFallback();\n        return __global__;\n      } finally {\n        delete Object.prototype.__global__;\n      }\n    }();\n  }\n});\n\n// node_modules/.pnpm/websocket@1.0.34/node_modules/websocket/package.json\nvar require_package = __commonJS({\n  \"node_modules/.pnpm/websocket@1.0.34/node_modules/websocket/package.json\"(exports, module) {\n    module.exports = {\n      name: \"websocket\",\n      description: \"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.\",\n      keywords: [\n        \"websocket\",\n        \"websockets\",\n        \"socket\",\n        \"networking\",\n        \"comet\",\n        \"push\",\n        \"RFC-6455\",\n        \"realtime\",\n        \"server\",\n        \"client\"\n      ],\n      author: \"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)\",\n      contributors: [\n        \"I\\xF1aki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)\"\n      ],\n      version: \"1.0.34\",\n      repository: {\n        type: \"git\",\n        url: \"https://github.com/theturtle32/WebSocket-Node.git\"\n      },\n      homepage: \"https://github.com/theturtle32/WebSocket-Node\",\n      engines: {\n        node: \">=4.0.0\"\n      },\n      dependencies: {\n        bufferutil: \"^4.0.1\",\n        debug: \"^2.2.0\",\n        \"es5-ext\": \"^0.10.50\",\n        \"typedarray-to-buffer\": \"^3.1.5\",\n        \"utf-8-validate\": \"^5.0.2\",\n        yaeti: \"^0.0.6\"\n      },\n      devDependencies: {\n        \"buffer-equal\": \"^1.0.0\",\n        gulp: \"^4.0.2\",\n        \"gulp-jshint\": \"^2.0.4\",\n        \"jshint-stylish\": \"^2.2.1\",\n        jshint: \"^2.0.0\",\n        tape: \"^4.9.1\"\n      },\n      config: {\n        verbose: false\n      },\n      scripts: {\n        test: \"tape test/unit/*.js\",\n        gulp: \"gulp\"\n      },\n      main: \"index\",\n      directories: {\n        lib: \"./lib\"\n      },\n      browser: \"lib/browser.js\",\n      license: \"Apache-2.0\"\n    };\n  }\n});\n\n// node_modules/.pnpm/websocket@1.0.34/node_modules/websocket/lib/version.js\nvar require_version = __commonJS({\n  \"node_modules/.pnpm/websocket@1.0.34/node_modules/websocket/lib/version.js\"(exports, module) {\n    module.exports = require_package().version;\n  }\n});\n\n// node_modules/.pnpm/websocket@1.0.34/node_modules/websocket/lib/browser.js\nvar require_browser = __commonJS({\n  \"node_modules/.pnpm/websocket@1.0.34/node_modules/websocket/lib/browser.js\"(exports, module) {\n    var _globalThis;\n    if (typeof globalThis === \"object\") {\n      _globalThis = globalThis;\n    } else {\n      try {\n        _globalThis = require_global();\n      } catch (error) {\n      } finally {\n        if (!_globalThis && typeof window !== \"undefined\") {\n          _globalThis = window;\n        }\n        if (!_globalThis) {\n          throw new Error(\"Could not determine global this\");\n        }\n      }\n    }\n    var NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\n    var websocket_version = require_version();\n    function W3CWebSocket(uri, protocols) {\n      var native_instance;\n      if (protocols) {\n        native_instance = new NativeWebSocket(uri, protocols);\n      } else {\n        native_instance = new NativeWebSocket(uri);\n      }\n      return native_instance;\n    }\n    if (NativeWebSocket) {\n      [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"].forEach(function(prop) {\n        Object.defineProperty(W3CWebSocket, prop, {\n          get: function() {\n            return NativeWebSocket[prop];\n          }\n        });\n      });\n    }\n    module.exports = {\n      \"w3cwebsocket\": NativeWebSocket ? W3CWebSocket : null,\n      \"version\": websocket_version\n    };\n  }\n});\n\n// node_modules/.pnpm/@supabase+functions-js@2.0.0/node_modules/@supabase/functions-js/dist/module/helper.js\nvar __awaiter = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar resolveFetch = (customFetch) => {\n  let _fetch;\n  if (customFetch) {\n    _fetch = customFetch;\n  } else if (typeof fetch === \"undefined\") {\n    _fetch = (...args) => __awaiter(void 0, void 0, void 0, function* () {\n      return yield (yield import(\"./browser-ponyfill-T7ISBDOE.js\")).fetch(...args);\n    });\n  } else {\n    _fetch = fetch;\n  }\n  return (...args) => _fetch(...args);\n};\n\n// node_modules/.pnpm/@supabase+functions-js@2.0.0/node_modules/@supabase/functions-js/dist/module/types.js\nvar FunctionsError = class extends Error {\n  constructor(message, name = \"FunctionsError\", context) {\n    super(message);\n    super.name = name;\n    this.context = context;\n  }\n};\nvar FunctionsFetchError = class extends FunctionsError {\n  constructor(context) {\n    super(\"Failed to send a request to the Edge Function\", \"FunctionsFetchError\", context);\n  }\n};\nvar FunctionsRelayError = class extends FunctionsError {\n  constructor(context) {\n    super(\"Relay Error invoking the Edge Function\", \"FunctionsRelayError\", context);\n  }\n};\nvar FunctionsHttpError = class extends FunctionsError {\n  constructor(context) {\n    super(\"Edge Function returned a non-2xx status code\", \"FunctionsHttpError\", context);\n  }\n};\n\n// node_modules/.pnpm/@supabase+functions-js@2.0.0/node_modules/@supabase/functions-js/dist/module/FunctionsClient.js\nvar __awaiter2 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar FunctionsClient = class {\n  constructor(url, { headers = {}, customFetch } = {}) {\n    this.url = url;\n    this.headers = headers;\n    this.fetch = resolveFetch(customFetch);\n  }\n  setAuth(token) {\n    this.headers.Authorization = `Bearer ${token}`;\n  }\n  invoke(functionName, invokeOptions = {}) {\n    var _a;\n    return __awaiter2(this, void 0, void 0, function* () {\n      try {\n        const { headers, body: functionArgs } = invokeOptions;\n        let _headers = {};\n        let body;\n        if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, \"Content-Type\") || !headers)) {\n          if (typeof Blob !== \"undefined\" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {\n            _headers[\"Content-Type\"] = \"application/octet-stream\";\n            body = functionArgs;\n          } else if (typeof functionArgs === \"string\") {\n            _headers[\"Content-Type\"] = \"text/plain\";\n            body = functionArgs;\n          } else if (typeof FormData !== \"undefined\" && functionArgs instanceof FormData) {\n            body = functionArgs;\n          } else {\n            _headers[\"Content-Type\"] = \"application/json\";\n            body = JSON.stringify(functionArgs);\n          }\n        }\n        const response = yield this.fetch(`${this.url}/${functionName}`, {\n          method: \"POST\",\n          headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),\n          body\n        }).catch((fetchError) => {\n          throw new FunctionsFetchError(fetchError);\n        });\n        const isRelayError = response.headers.get(\"x-relay-error\");\n        if (isRelayError && isRelayError === \"true\") {\n          throw new FunctionsRelayError(response);\n        }\n        if (!response.ok) {\n          throw new FunctionsHttpError(response);\n        }\n        let responseType = ((_a = response.headers.get(\"Content-Type\")) !== null && _a !== void 0 ? _a : \"text/plain\").split(\";\")[0].trim();\n        let data;\n        if (responseType === \"application/json\") {\n          data = yield response.json();\n        } else if (responseType === \"application/octet-stream\") {\n          data = yield response.blob();\n        } else if (responseType === \"multipart/form-data\") {\n          data = yield response.formData();\n        } else {\n          data = yield response.text();\n        }\n        return { data, error: null };\n      } catch (error) {\n        return { data: null, error };\n      }\n    });\n  }\n};\n\n// node_modules/.pnpm/@supabase+postgrest-js@1.1.0/node_modules/@supabase/postgrest-js/dist/module/PostgrestBuilder.js\nvar import_cross_fetch = __toESM(require_browser_ponyfill());\nvar __awaiter3 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar PostgrestBuilder = class {\n  constructor(builder) {\n    this.shouldThrowOnError = false;\n    this.method = builder.method;\n    this.url = builder.url;\n    this.headers = builder.headers;\n    this.schema = builder.schema;\n    this.body = builder.body;\n    this.shouldThrowOnError = builder.shouldThrowOnError;\n    this.signal = builder.signal;\n    this.allowEmpty = builder.allowEmpty;\n    if (builder.fetch) {\n      this.fetch = builder.fetch;\n    } else if (typeof fetch === \"undefined\") {\n      this.fetch = import_cross_fetch.default;\n    } else {\n      this.fetch = fetch;\n    }\n  }\n  throwOnError() {\n    this.shouldThrowOnError = true;\n    return this;\n  }\n  then(onfulfilled, onrejected) {\n    if (this.schema === void 0) {\n    } else if ([\"GET\", \"HEAD\"].includes(this.method)) {\n      this.headers[\"Accept-Profile\"] = this.schema;\n    } else {\n      this.headers[\"Content-Profile\"] = this.schema;\n    }\n    if (this.method !== \"GET\" && this.method !== \"HEAD\") {\n      this.headers[\"Content-Type\"] = \"application/json\";\n    }\n    const _fetch = this.fetch;\n    let res = _fetch(this.url.toString(), {\n      method: this.method,\n      headers: this.headers,\n      body: JSON.stringify(this.body),\n      signal: this.signal\n    }).then((res2) => __awaiter3(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n      let error = null;\n      let data = null;\n      let count = null;\n      let status = res2.status;\n      let statusText = res2.statusText;\n      if (res2.ok) {\n        if (this.method !== \"HEAD\") {\n          const body = yield res2.text();\n          if (body === \"\") {\n          } else if (this.headers[\"Accept\"] === \"text/csv\") {\n            data = body;\n          } else if (this.headers[\"Accept\"] && this.headers[\"Accept\"].includes(\"application/vnd.pgrst.plan+text\")) {\n            data = body;\n          } else {\n            data = JSON.parse(body);\n          }\n        }\n        const countHeader = (_a = this.headers[\"Prefer\"]) === null || _a === void 0 ? void 0 : _a.match(/count=(exact|planned|estimated)/);\n        const contentRange = (_b = res2.headers.get(\"content-range\")) === null || _b === void 0 ? void 0 : _b.split(\"/\");\n        if (countHeader && contentRange && contentRange.length > 1) {\n          count = parseInt(contentRange[1]);\n        }\n      } else {\n        const body = yield res2.text();\n        try {\n          error = JSON.parse(body);\n        } catch (_d) {\n          error = {\n            message: body\n          };\n        }\n        if (error && this.allowEmpty && ((_c = error === null || error === void 0 ? void 0 : error.details) === null || _c === void 0 ? void 0 : _c.includes(\"Results contain 0 rows\"))) {\n          error = null;\n          status = 200;\n          statusText = \"OK\";\n        }\n        if (error && this.shouldThrowOnError) {\n          throw error;\n        }\n      }\n      const postgrestResponse = {\n        error,\n        data,\n        count,\n        status,\n        statusText\n      };\n      return postgrestResponse;\n    }));\n    if (!this.shouldThrowOnError) {\n      res = res.catch((fetchError) => ({\n        error: {\n          message: `FetchError: ${fetchError.message}`,\n          details: \"\",\n          hint: \"\",\n          code: fetchError.code || \"\"\n        },\n        data: null,\n        count: null,\n        status: 0,\n        statusText: \"\"\n      }));\n    }\n    return res.then(onfulfilled, onrejected);\n  }\n};\n\n// node_modules/.pnpm/@supabase+postgrest-js@1.1.0/node_modules/@supabase/postgrest-js/dist/module/PostgrestTransformBuilder.js\nvar PostgrestTransformBuilder = class extends PostgrestBuilder {\n  select(columns) {\n    let quoted = false;\n    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c) => {\n      if (/\\s/.test(c) && !quoted) {\n        return \"\";\n      }\n      if (c === '\"') {\n        quoted = !quoted;\n      }\n      return c;\n    }).join(\"\");\n    this.url.searchParams.set(\"select\", cleanedColumns);\n    if (this.headers[\"Prefer\"]) {\n      this.headers[\"Prefer\"] += \",\";\n    }\n    this.headers[\"Prefer\"] += \"return=representation\";\n    return this;\n  }\n  order(column, { ascending = true, nullsFirst, foreignTable } = {}) {\n    const key = foreignTable ? `${foreignTable}.order` : \"order\";\n    const existingOrder = this.url.searchParams.get(key);\n    this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : \"\"}${column}.${ascending ? \"asc\" : \"desc\"}${nullsFirst === void 0 ? \"\" : nullsFirst ? \".nullsfirst\" : \".nullslast\"}`);\n    return this;\n  }\n  limit(count, { foreignTable } = {}) {\n    const key = typeof foreignTable === \"undefined\" ? \"limit\" : `${foreignTable}.limit`;\n    this.url.searchParams.set(key, `${count}`);\n    return this;\n  }\n  range(from, to, { foreignTable } = {}) {\n    const keyOffset = typeof foreignTable === \"undefined\" ? \"offset\" : `${foreignTable}.offset`;\n    const keyLimit = typeof foreignTable === \"undefined\" ? \"limit\" : `${foreignTable}.limit`;\n    this.url.searchParams.set(keyOffset, `${from}`);\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`);\n    return this;\n  }\n  abortSignal(signal) {\n    this.signal = signal;\n    return this;\n  }\n  single() {\n    this.headers[\"Accept\"] = \"application/vnd.pgrst.object+json\";\n    return this;\n  }\n  maybeSingle() {\n    this.headers[\"Accept\"] = \"application/vnd.pgrst.object+json\";\n    this.allowEmpty = true;\n    return this;\n  }\n  csv() {\n    this.headers[\"Accept\"] = \"text/csv\";\n    return this;\n  }\n  geojson() {\n    this.headers[\"Accept\"] = \"application/geo+json\";\n    return this;\n  }\n  explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = \"text\" } = {}) {\n    const options = [\n      analyze ? \"analyze\" : null,\n      verbose ? \"verbose\" : null,\n      settings ? \"settings\" : null,\n      buffers ? \"buffers\" : null,\n      wal ? \"wal\" : null\n    ].filter(Boolean).join(\"|\");\n    const forMediatype = this.headers[\"Accept\"];\n    this.headers[\"Accept\"] = `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`;\n    if (format === \"json\")\n      return this;\n    else\n      return this;\n  }\n  rollback() {\n    var _a;\n    if (((_a = this.headers[\"Prefer\"]) !== null && _a !== void 0 ? _a : \"\").trim().length > 0) {\n      this.headers[\"Prefer\"] += \",tx=rollback\";\n    } else {\n      this.headers[\"Prefer\"] = \"tx=rollback\";\n    }\n    return this;\n  }\n  returns() {\n    return this;\n  }\n};\n\n// node_modules/.pnpm/@supabase+postgrest-js@1.1.0/node_modules/@supabase/postgrest-js/dist/module/PostgrestFilterBuilder.js\nvar PostgrestFilterBuilder = class extends PostgrestTransformBuilder {\n  eq(column, value) {\n    this.url.searchParams.append(column, `eq.${value}`);\n    return this;\n  }\n  neq(column, value) {\n    this.url.searchParams.append(column, `neq.${value}`);\n    return this;\n  }\n  gt(column, value) {\n    this.url.searchParams.append(column, `gt.${value}`);\n    return this;\n  }\n  gte(column, value) {\n    this.url.searchParams.append(column, `gte.${value}`);\n    return this;\n  }\n  lt(column, value) {\n    this.url.searchParams.append(column, `lt.${value}`);\n    return this;\n  }\n  lte(column, value) {\n    this.url.searchParams.append(column, `lte.${value}`);\n    return this;\n  }\n  like(column, pattern) {\n    this.url.searchParams.append(column, `like.${pattern}`);\n    return this;\n  }\n  ilike(column, pattern) {\n    this.url.searchParams.append(column, `ilike.${pattern}`);\n    return this;\n  }\n  is(column, value) {\n    this.url.searchParams.append(column, `is.${value}`);\n    return this;\n  }\n  in(column, values) {\n    const cleanedValues = values.map((s) => {\n      if (typeof s === \"string\" && new RegExp(\"[,()]\").test(s))\n        return `\"${s}\"`;\n      else\n        return `${s}`;\n    }).join(\",\");\n    this.url.searchParams.append(column, `in.(${cleanedValues})`);\n    return this;\n  }\n  contains(column, value) {\n    if (typeof value === \"string\") {\n      this.url.searchParams.append(column, `cs.${value}`);\n    } else if (Array.isArray(value)) {\n      this.url.searchParams.append(column, `cs.{${value.join(\",\")}}`);\n    } else {\n      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);\n    }\n    return this;\n  }\n  containedBy(column, value) {\n    if (typeof value === \"string\") {\n      this.url.searchParams.append(column, `cd.${value}`);\n    } else if (Array.isArray(value)) {\n      this.url.searchParams.append(column, `cd.{${value.join(\",\")}}`);\n    } else {\n      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);\n    }\n    return this;\n  }\n  rangeGt(column, range) {\n    this.url.searchParams.append(column, `sr.${range}`);\n    return this;\n  }\n  rangeGte(column, range) {\n    this.url.searchParams.append(column, `nxl.${range}`);\n    return this;\n  }\n  rangeLt(column, range) {\n    this.url.searchParams.append(column, `sl.${range}`);\n    return this;\n  }\n  rangeLte(column, range) {\n    this.url.searchParams.append(column, `nxr.${range}`);\n    return this;\n  }\n  rangeAdjacent(column, range) {\n    this.url.searchParams.append(column, `adj.${range}`);\n    return this;\n  }\n  overlaps(column, value) {\n    if (typeof value === \"string\") {\n      this.url.searchParams.append(column, `ov.${value}`);\n    } else {\n      this.url.searchParams.append(column, `ov.{${value.join(\",\")}}`);\n    }\n    return this;\n  }\n  textSearch(column, query, { config, type } = {}) {\n    let typePart = \"\";\n    if (type === \"plain\") {\n      typePart = \"pl\";\n    } else if (type === \"phrase\") {\n      typePart = \"ph\";\n    } else if (type === \"websearch\") {\n      typePart = \"w\";\n    }\n    const configPart = config === void 0 ? \"\" : `(${config})`;\n    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);\n    return this;\n  }\n  match(query) {\n    Object.entries(query).forEach(([column, value]) => {\n      this.url.searchParams.append(column, `eq.${value}`);\n    });\n    return this;\n  }\n  not(column, operator, value) {\n    this.url.searchParams.append(column, `not.${operator}.${value}`);\n    return this;\n  }\n  or(filters, { foreignTable } = {}) {\n    const key = foreignTable ? `${foreignTable}.or` : \"or\";\n    this.url.searchParams.append(key, `(${filters})`);\n    return this;\n  }\n  filter(column, operator, value) {\n    this.url.searchParams.append(column, `${operator}.${value}`);\n    return this;\n  }\n};\n\n// node_modules/.pnpm/@supabase+postgrest-js@1.1.0/node_modules/@supabase/postgrest-js/dist/module/PostgrestQueryBuilder.js\nvar PostgrestQueryBuilder = class {\n  constructor(url, { headers = {}, schema, fetch: fetch2 }) {\n    this.url = url;\n    this.headers = headers;\n    this.schema = schema;\n    this.fetch = fetch2;\n  }\n  select(columns, { head = false, count } = {}) {\n    const method = head ? \"HEAD\" : \"GET\";\n    let quoted = false;\n    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c) => {\n      if (/\\s/.test(c) && !quoted) {\n        return \"\";\n      }\n      if (c === '\"') {\n        quoted = !quoted;\n      }\n      return c;\n    }).join(\"\");\n    this.url.searchParams.set(\"select\", cleanedColumns);\n    if (count) {\n      this.headers[\"Prefer\"] = `count=${count}`;\n    }\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  insert(values, { count } = {}) {\n    const method = \"POST\";\n    const prefersHeaders = [];\n    const body = values;\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n    if (this.headers[\"Prefer\"]) {\n      prefersHeaders.unshift(this.headers[\"Prefer\"]);\n    }\n    this.headers[\"Prefer\"] = prefersHeaders.join(\",\");\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`);\n        this.url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n      }\n    }\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  upsert(values, { onConflict, ignoreDuplicates = false, count } = {}) {\n    const method = \"POST\";\n    const prefersHeaders = [`resolution=${ignoreDuplicates ? \"ignore\" : \"merge\"}-duplicates`];\n    if (onConflict !== void 0)\n      this.url.searchParams.set(\"on_conflict\", onConflict);\n    const body = values;\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n    if (this.headers[\"Prefer\"]) {\n      prefersHeaders.unshift(this.headers[\"Prefer\"]);\n    }\n    this.headers[\"Prefer\"] = prefersHeaders.join(\",\");\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  update(values, { count } = {}) {\n    const method = \"PATCH\";\n    const prefersHeaders = [];\n    const body = values;\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n    if (this.headers[\"Prefer\"]) {\n      prefersHeaders.unshift(this.headers[\"Prefer\"]);\n    }\n    this.headers[\"Prefer\"] = prefersHeaders.join(\",\");\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  delete({ count } = {}) {\n    const method = \"DELETE\";\n    const prefersHeaders = [];\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n    if (this.headers[\"Prefer\"]) {\n      prefersHeaders.unshift(this.headers[\"Prefer\"]);\n    }\n    this.headers[\"Prefer\"] = prefersHeaders.join(\",\");\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n};\n\n// node_modules/.pnpm/@supabase+postgrest-js@1.1.0/node_modules/@supabase/postgrest-js/dist/module/version.js\nvar version = \"1.1.0\";\n\n// node_modules/.pnpm/@supabase+postgrest-js@1.1.0/node_modules/@supabase/postgrest-js/dist/module/constants.js\nvar DEFAULT_HEADERS = { \"X-Client-Info\": `postgrest-js/${version}` };\n\n// node_modules/.pnpm/@supabase+postgrest-js@1.1.0/node_modules/@supabase/postgrest-js/dist/module/PostgrestClient.js\nvar PostgrestClient = class {\n  constructor(url, { headers = {}, schema, fetch: fetch2 } = {}) {\n    this.url = url;\n    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers);\n    this.schema = schema;\n    this.fetch = fetch2;\n  }\n  from(relation) {\n    const url = new URL(`${this.url}/${relation}`);\n    return new PostgrestQueryBuilder(url, {\n      headers: Object.assign({}, this.headers),\n      schema: this.schema,\n      fetch: this.fetch\n    });\n  }\n  rpc(fn, args = {}, { head = false, count } = {}) {\n    let method;\n    const url = new URL(`${this.url}/rpc/${fn}`);\n    let body;\n    if (head) {\n      method = \"HEAD\";\n      Object.entries(args).forEach(([name, value]) => {\n        url.searchParams.append(name, `${value}`);\n      });\n    } else {\n      method = \"POST\";\n      body = args;\n    }\n    const headers = Object.assign({}, this.headers);\n    if (count) {\n      headers[\"Prefer\"] = `count=${count}`;\n    }\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n};\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\nvar import_websocket = __toESM(require_browser());\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/lib/version.js\nvar version2 = \"2.1.0\";\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/lib/constants.js\nvar DEFAULT_HEADERS2 = { \"X-Client-Info\": `realtime-js/${version2}` };\nvar VSN = \"1.0.0\";\nvar DEFAULT_TIMEOUT = 1e4;\nvar WS_CLOSE_NORMAL = 1e3;\nvar SOCKET_STATES;\n(function(SOCKET_STATES2) {\n  SOCKET_STATES2[SOCKET_STATES2[\"connecting\"] = 0] = \"connecting\";\n  SOCKET_STATES2[SOCKET_STATES2[\"open\"] = 1] = \"open\";\n  SOCKET_STATES2[SOCKET_STATES2[\"closing\"] = 2] = \"closing\";\n  SOCKET_STATES2[SOCKET_STATES2[\"closed\"] = 3] = \"closed\";\n})(SOCKET_STATES || (SOCKET_STATES = {}));\nvar CHANNEL_STATES;\n(function(CHANNEL_STATES2) {\n  CHANNEL_STATES2[\"closed\"] = \"closed\";\n  CHANNEL_STATES2[\"errored\"] = \"errored\";\n  CHANNEL_STATES2[\"joined\"] = \"joined\";\n  CHANNEL_STATES2[\"joining\"] = \"joining\";\n  CHANNEL_STATES2[\"leaving\"] = \"leaving\";\n})(CHANNEL_STATES || (CHANNEL_STATES = {}));\nvar CHANNEL_EVENTS;\n(function(CHANNEL_EVENTS2) {\n  CHANNEL_EVENTS2[\"close\"] = \"phx_close\";\n  CHANNEL_EVENTS2[\"error\"] = \"phx_error\";\n  CHANNEL_EVENTS2[\"join\"] = \"phx_join\";\n  CHANNEL_EVENTS2[\"reply\"] = \"phx_reply\";\n  CHANNEL_EVENTS2[\"leave\"] = \"phx_leave\";\n  CHANNEL_EVENTS2[\"access_token\"] = \"access_token\";\n})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));\nvar TRANSPORTS;\n(function(TRANSPORTS2) {\n  TRANSPORTS2[\"websocket\"] = \"websocket\";\n})(TRANSPORTS || (TRANSPORTS = {}));\nvar CONNECTION_STATE;\n(function(CONNECTION_STATE2) {\n  CONNECTION_STATE2[\"Connecting\"] = \"connecting\";\n  CONNECTION_STATE2[\"Open\"] = \"open\";\n  CONNECTION_STATE2[\"Closing\"] = \"closing\";\n  CONNECTION_STATE2[\"Closed\"] = \"closed\";\n})(CONNECTION_STATE || (CONNECTION_STATE = {}));\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/lib/timer.js\nvar Timer = class {\n  constructor(callback, timerCalc) {\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = void 0;\n    this.tries = 0;\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n  }\n  reset() {\n    this.tries = 0;\n    clearTimeout(this.timer);\n  }\n  scheduleTimeout() {\n    clearTimeout(this.timer);\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1;\n      this.callback();\n    }, this.timerCalc(this.tries + 1));\n  }\n};\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/lib/serializer.js\nvar Serializer = class {\n  constructor() {\n    this.HEADER_LENGTH = 1;\n  }\n  decode(rawPayload, callback) {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this._binaryDecode(rawPayload));\n    }\n    if (typeof rawPayload === \"string\") {\n      return callback(JSON.parse(rawPayload));\n    }\n    return callback({});\n  }\n  _binaryDecode(buffer) {\n    const view = new DataView(buffer);\n    const decoder = new TextDecoder();\n    return this._decodeBroadcast(buffer, view, decoder);\n  }\n  _decodeBroadcast(buffer, view, decoder) {\n    const topicSize = view.getUint8(1);\n    const eventSize = view.getUint8(2);\n    let offset = this.HEADER_LENGTH + 2;\n    const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    const event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));\n    return { ref: null, topic, event, payload: data };\n  }\n};\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/lib/push.js\nvar Push = class {\n  constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload;\n    this.timeout = timeout;\n    this.sent = false;\n    this.timeoutTimer = void 0;\n    this.ref = \"\";\n    this.receivedResp = null;\n    this.recHooks = [];\n    this.refEvent = null;\n    this.rateLimited = false;\n  }\n  resend(timeout) {\n    this.timeout = timeout;\n    this._cancelRefEvent();\n    this.ref = \"\";\n    this.refEvent = null;\n    this.receivedResp = null;\n    this.sent = false;\n    this.send();\n  }\n  send() {\n    if (this._hasReceived(\"timeout\")) {\n      return;\n    }\n    this.startTimeout();\n    this.sent = true;\n    const status = this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload,\n      ref: this.ref,\n      join_ref: this.channel._joinRef()\n    });\n    if (status === \"rate limited\") {\n      this.rateLimited = true;\n    }\n  }\n  updatePayload(payload) {\n    this.payload = Object.assign(Object.assign({}, this.payload), payload);\n  }\n  receive(status, callback) {\n    var _a;\n    if (this._hasReceived(status)) {\n      callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n    }\n    this.recHooks.push({ status, callback });\n    return this;\n  }\n  startTimeout() {\n    if (this.timeoutTimer) {\n      return;\n    }\n    this.ref = this.channel.socket._makeRef();\n    this.refEvent = this.channel._replyEventName(this.ref);\n    const callback = (payload) => {\n      this._cancelRefEvent();\n      this._cancelTimeout();\n      this.receivedResp = payload;\n      this._matchReceive(payload);\n    };\n    this.channel._on(this.refEvent, {}, callback);\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger(\"timeout\", {});\n    }, this.timeout);\n  }\n  trigger(status, response) {\n    if (this.refEvent)\n      this.channel._trigger(this.refEvent, { status, response });\n  }\n  destroy() {\n    this._cancelRefEvent();\n    this._cancelTimeout();\n  }\n  _cancelRefEvent() {\n    if (!this.refEvent) {\n      return;\n    }\n    this.channel._off(this.refEvent, {});\n  }\n  _cancelTimeout() {\n    clearTimeout(this.timeoutTimer);\n    this.timeoutTimer = void 0;\n  }\n  _matchReceive({ status, response }) {\n    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));\n  }\n  _hasReceived(status) {\n    return this.receivedResp && this.receivedResp.status === status;\n  }\n};\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\nvar REALTIME_PRESENCE_LISTEN_EVENTS;\n(function(REALTIME_PRESENCE_LISTEN_EVENTS2) {\n  REALTIME_PRESENCE_LISTEN_EVENTS2[\"SYNC\"] = \"sync\";\n  REALTIME_PRESENCE_LISTEN_EVENTS2[\"JOIN\"] = \"join\";\n  REALTIME_PRESENCE_LISTEN_EVENTS2[\"LEAVE\"] = \"leave\";\n})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));\nvar RealtimePresence = class {\n  constructor(channel, opts) {\n    this.channel = channel;\n    this.state = {};\n    this.pendingDiffs = [];\n    this.joinRef = null;\n    this.caller = {\n      onJoin: () => {\n      },\n      onLeave: () => {\n      },\n      onSync: () => {\n      }\n    };\n    const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {\n      state: \"presence_state\",\n      diff: \"presence_diff\"\n    };\n    this.channel._on(events.state, {}, (newState) => {\n      const { onJoin, onLeave, onSync } = this.caller;\n      this.joinRef = this.channel._joinRef();\n      this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);\n      this.pendingDiffs.forEach((diff) => {\n        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n      });\n      this.pendingDiffs = [];\n      onSync();\n    });\n    this.channel._on(events.diff, {}, (diff) => {\n      const { onJoin, onLeave, onSync } = this.caller;\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff);\n      } else {\n        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n        onSync();\n      }\n    });\n    this.onJoin((key, currentPresences, newPresences) => {\n      this.channel._trigger(\"presence\", {\n        event: \"join\",\n        key,\n        currentPresences,\n        newPresences\n      });\n    });\n    this.onLeave((key, currentPresences, leftPresences) => {\n      this.channel._trigger(\"presence\", {\n        event: \"leave\",\n        key,\n        currentPresences,\n        leftPresences\n      });\n    });\n    this.onSync(() => {\n      this.channel._trigger(\"presence\", { event: \"sync\" });\n    });\n  }\n  static syncState(currentState, newState, onJoin, onLeave) {\n    const state = this.cloneDeep(currentState);\n    const transformedState = this.transformState(newState);\n    const joins = {};\n    const leaves = {};\n    this.map(state, (key, presences) => {\n      if (!transformedState[key]) {\n        leaves[key] = presences;\n      }\n    });\n    this.map(transformedState, (key, newPresences) => {\n      const currentPresences = state[key];\n      if (currentPresences) {\n        const newPresenceRefs = newPresences.map((m) => m.presence_ref);\n        const curPresenceRefs = currentPresences.map((m) => m.presence_ref);\n        const joinedPresences = newPresences.filter((m) => curPresenceRefs.indexOf(m.presence_ref) < 0);\n        const leftPresences = currentPresences.filter((m) => newPresenceRefs.indexOf(m.presence_ref) < 0);\n        if (joinedPresences.length > 0) {\n          joins[key] = joinedPresences;\n        }\n        if (leftPresences.length > 0) {\n          leaves[key] = leftPresences;\n        }\n      } else {\n        joins[key] = newPresences;\n      }\n    });\n    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);\n  }\n  static syncDiff(state, diff, onJoin, onLeave) {\n    const { joins, leaves } = {\n      joins: this.transformState(diff.joins),\n      leaves: this.transformState(diff.leaves)\n    };\n    if (!onJoin) {\n      onJoin = () => {\n      };\n    }\n    if (!onLeave) {\n      onLeave = () => {\n      };\n    }\n    this.map(joins, (key, newPresences) => {\n      var _a;\n      const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];\n      state[key] = this.cloneDeep(newPresences);\n      if (currentPresences.length > 0) {\n        const joinedPresenceRefs = state[key].map((m) => m.presence_ref);\n        const curPresences = currentPresences.filter((m) => joinedPresenceRefs.indexOf(m.presence_ref) < 0);\n        state[key].unshift(...curPresences);\n      }\n      onJoin(key, currentPresences, newPresences);\n    });\n    this.map(leaves, (key, leftPresences) => {\n      let currentPresences = state[key];\n      if (!currentPresences)\n        return;\n      const presenceRefsToRemove = leftPresences.map((m) => m.presence_ref);\n      currentPresences = currentPresences.filter((m) => presenceRefsToRemove.indexOf(m.presence_ref) < 0);\n      state[key] = currentPresences;\n      onLeave(key, currentPresences, leftPresences);\n      if (currentPresences.length === 0)\n        delete state[key];\n    });\n    return state;\n  }\n  static map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));\n  }\n  static transformState(state) {\n    state = this.cloneDeep(state);\n    return Object.getOwnPropertyNames(state).reduce((newState, key) => {\n      const presences = state[key];\n      if (\"metas\" in presences) {\n        newState[key] = presences.metas.map((presence) => {\n          presence[\"presence_ref\"] = presence[\"phx_ref\"];\n          delete presence[\"phx_ref\"];\n          delete presence[\"phx_ref_prev\"];\n          return presence;\n        });\n      } else {\n        newState[key] = presences;\n      }\n      return newState;\n    }, {});\n  }\n  static cloneDeep(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n  onJoin(callback) {\n    this.caller.onJoin = callback;\n  }\n  onLeave(callback) {\n    this.caller.onLeave = callback;\n  }\n  onSync(callback) {\n    this.caller.onSync = callback;\n  }\n  inPendingSyncState() {\n    return !this.joinRef || this.joinRef !== this.channel._joinRef();\n  }\n};\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\nvar PostgresTypes;\n(function(PostgresTypes2) {\n  PostgresTypes2[\"abstime\"] = \"abstime\";\n  PostgresTypes2[\"bool\"] = \"bool\";\n  PostgresTypes2[\"date\"] = \"date\";\n  PostgresTypes2[\"daterange\"] = \"daterange\";\n  PostgresTypes2[\"float4\"] = \"float4\";\n  PostgresTypes2[\"float8\"] = \"float8\";\n  PostgresTypes2[\"int2\"] = \"int2\";\n  PostgresTypes2[\"int4\"] = \"int4\";\n  PostgresTypes2[\"int4range\"] = \"int4range\";\n  PostgresTypes2[\"int8\"] = \"int8\";\n  PostgresTypes2[\"int8range\"] = \"int8range\";\n  PostgresTypes2[\"json\"] = \"json\";\n  PostgresTypes2[\"jsonb\"] = \"jsonb\";\n  PostgresTypes2[\"money\"] = \"money\";\n  PostgresTypes2[\"numeric\"] = \"numeric\";\n  PostgresTypes2[\"oid\"] = \"oid\";\n  PostgresTypes2[\"reltime\"] = \"reltime\";\n  PostgresTypes2[\"text\"] = \"text\";\n  PostgresTypes2[\"time\"] = \"time\";\n  PostgresTypes2[\"timestamp\"] = \"timestamp\";\n  PostgresTypes2[\"timestamptz\"] = \"timestamptz\";\n  PostgresTypes2[\"timetz\"] = \"timetz\";\n  PostgresTypes2[\"tsrange\"] = \"tsrange\";\n  PostgresTypes2[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\nvar convertChangeData = (columns, record, options = {}) => {\n  var _a;\n  const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n  return Object.keys(record).reduce((acc, rec_key) => {\n    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);\n    return acc;\n  }, {});\n};\nvar convertColumn = (columnName, columns, record, skipTypes) => {\n  const column = columns.find((x) => x.name === columnName);\n  const colType = column === null || column === void 0 ? void 0 : column.type;\n  const value = record[columnName];\n  if (colType && !skipTypes.includes(colType)) {\n    return convertCell(colType, value);\n  }\n  return noop(value);\n};\nvar convertCell = (type, value) => {\n  if (type.charAt(0) === \"_\") {\n    const dataType = type.slice(1, type.length);\n    return toArray(value, dataType);\n  }\n  switch (type) {\n    case PostgresTypes.bool:\n      return toBoolean(value);\n    case PostgresTypes.float4:\n    case PostgresTypes.float8:\n    case PostgresTypes.int2:\n    case PostgresTypes.int4:\n    case PostgresTypes.int8:\n    case PostgresTypes.numeric:\n    case PostgresTypes.oid:\n      return toNumber(value);\n    case PostgresTypes.json:\n    case PostgresTypes.jsonb:\n      return toJson(value);\n    case PostgresTypes.timestamp:\n      return toTimestampString(value);\n    case PostgresTypes.abstime:\n    case PostgresTypes.date:\n    case PostgresTypes.daterange:\n    case PostgresTypes.int4range:\n    case PostgresTypes.int8range:\n    case PostgresTypes.money:\n    case PostgresTypes.reltime:\n    case PostgresTypes.text:\n    case PostgresTypes.time:\n    case PostgresTypes.timestamptz:\n    case PostgresTypes.timetz:\n    case PostgresTypes.tsrange:\n    case PostgresTypes.tstzrange:\n      return noop(value);\n    default:\n      return noop(value);\n  }\n};\nvar noop = (value) => {\n  return value;\n};\nvar toBoolean = (value) => {\n  switch (value) {\n    case \"t\":\n      return true;\n    case \"f\":\n      return false;\n    default:\n      return value;\n  }\n};\nvar toNumber = (value) => {\n  if (typeof value === \"string\") {\n    const parsedValue = parseFloat(value);\n    if (!Number.isNaN(parsedValue)) {\n      return parsedValue;\n    }\n  }\n  return value;\n};\nvar toJson = (value) => {\n  if (typeof value === \"string\") {\n    try {\n      return JSON.parse(value);\n    } catch (error) {\n      console.log(`JSON parse error: ${error}`);\n      return value;\n    }\n  }\n  return value;\n};\nvar toArray = (value, type) => {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  const lastIdx = value.length - 1;\n  const closeBrace = value[lastIdx];\n  const openBrace = value[0];\n  if (openBrace === \"{\" && closeBrace === \"}\") {\n    let arr;\n    const valTrim = value.slice(1, lastIdx);\n    try {\n      arr = JSON.parse(\"[\" + valTrim + \"]\");\n    } catch (_) {\n      arr = valTrim ? valTrim.split(\",\") : [];\n    }\n    return arr.map((val) => convertCell(type, val));\n  }\n  return value;\n};\nvar toTimestampString = (value) => {\n  if (typeof value === \"string\") {\n    return value.replace(\" \", \"T\");\n  }\n  return value;\n};\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\nvar __awaiter4 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2) {\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2[\"ALL\"] = \"*\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2[\"INSERT\"] = \"INSERT\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2[\"UPDATE\"] = \"UPDATE\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nvar REALTIME_LISTEN_TYPES;\n(function(REALTIME_LISTEN_TYPES2) {\n  REALTIME_LISTEN_TYPES2[\"BROADCAST\"] = \"broadcast\";\n  REALTIME_LISTEN_TYPES2[\"PRESENCE\"] = \"presence\";\n  REALTIME_LISTEN_TYPES2[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nvar REALTIME_SUBSCRIBE_STATES;\n(function(REALTIME_SUBSCRIBE_STATES2) {\n  REALTIME_SUBSCRIBE_STATES2[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n  REALTIME_SUBSCRIBE_STATES2[\"TIMED_OUT\"] = \"TIMED_OUT\";\n  REALTIME_SUBSCRIBE_STATES2[\"CLOSED\"] = \"CLOSED\";\n  REALTIME_SUBSCRIBE_STATES2[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nvar RealtimeChannel = class {\n  constructor(topic, params = { config: {} }, socket) {\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = {};\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.params.config = Object.assign({\n      broadcast: { ack: false, self: false },\n      presence: { key: \"\" }\n    }, params.config);\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n    this.joinPush.receive(\"ok\", () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this._onClose(() => {\n      this.rejoinTimer.reset();\n      this.socket.log(\"channel\", `close ${this.topic} ${this._joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket._remove(this);\n    });\n    this._onError((reason) => {\n      if (this._isLeaving() || this._isClosed()) {\n        return;\n      }\n      this.socket.log(\"channel\", `error ${this.topic}`, reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive(\"timeout\", () => {\n      if (!this._isJoining()) {\n        return;\n      }\n      this.socket.log(\"channel\", `timeout ${this.topic}`, this.joinPush.timeout);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n      this._trigger(this._replyEventName(ref), payload);\n    });\n    this.presence = new RealtimePresence(this);\n  }\n  subscribe(callback, timeout = this.timeout) {\n    var _a, _b;\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n    } else {\n      const { config: { broadcast, presence } } = this.params;\n      this._onError((e) => callback && callback(\"CHANNEL_ERROR\", e));\n      this._onClose(() => callback && callback(\"CLOSED\"));\n      const accessTokenPayload = {};\n      const config = {\n        broadcast,\n        presence,\n        postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r) => r.filter)) !== null && _b !== void 0 ? _b : []\n      };\n      if (this.socket.accessToken) {\n        accessTokenPayload.access_token = this.socket.accessToken;\n      }\n      this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));\n      this.joinedOnce = true;\n      this._rejoin(timeout);\n      this.joinPush.receive(\"ok\", ({ postgres_changes: serverPostgresFilters }) => {\n        var _a2;\n        this.socket.accessToken && this.socket.setAuth(this.socket.accessToken);\n        if (serverPostgresFilters === void 0) {\n          callback && callback(\"SUBSCRIBED\");\n          return;\n        } else {\n          const clientPostgresBindings = this.bindings.postgres_changes;\n          const bindingsLen = (_a2 = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a2 !== void 0 ? _a2 : 0;\n          const newPostgresBindings = [];\n          for (let i = 0; i < bindingsLen; i++) {\n            const clientPostgresBinding = clientPostgresBindings[i];\n            const { filter: { event, schema, table, filter } } = clientPostgresBinding;\n            const serverPostgresFilter = serverPostgresFilters && serverPostgresFilters[i];\n            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {\n              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));\n            } else {\n              this.unsubscribe();\n              callback && callback(\"CHANNEL_ERROR\", new Error(\"mismatch between server and client bindings for postgres changes\"));\n              return;\n            }\n          }\n          this.bindings.postgres_changes = newPostgresBindings;\n          callback && callback(\"SUBSCRIBED\");\n          return;\n        }\n      }).receive(\"error\", (error) => {\n        callback && callback(\"CHANNEL_ERROR\", new Error(JSON.stringify(Object.values(error).join(\", \") || \"error\")));\n        return;\n      }).receive(\"timeout\", () => {\n        callback && callback(\"TIMED_OUT\");\n        return;\n      });\n    }\n    return this;\n  }\n  presenceState() {\n    return this.presence.state;\n  }\n  track(payload, opts = {}) {\n    return __awaiter4(this, void 0, void 0, function* () {\n      return yield this.send({\n        type: \"presence\",\n        event: \"track\",\n        payload\n      }, opts.timeout || this.timeout);\n    });\n  }\n  untrack(opts = {}) {\n    return __awaiter4(this, void 0, void 0, function* () {\n      return yield this.send({\n        type: \"presence\",\n        event: \"untrack\"\n      }, opts);\n    });\n  }\n  on(type, filter, callback) {\n    return this._on(type, filter, callback);\n  }\n  send(payload, opts = {}) {\n    return new Promise((resolve) => {\n      var _a, _b, _c;\n      const push = this._push(payload.type, payload, opts.timeout || this.timeout);\n      if (push.rateLimited) {\n        resolve(\"rate limited\");\n      }\n      if (payload.type === \"broadcast\" && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n        resolve(\"ok\");\n      }\n      push.receive(\"ok\", () => resolve(\"ok\"));\n      push.receive(\"timeout\", () => resolve(\"timed out\"));\n    });\n  }\n  updateJoinPayload(payload) {\n    this.joinPush.updatePayload(payload);\n  }\n  unsubscribe(timeout = this.timeout) {\n    this.state = CHANNEL_STATES.leaving;\n    const onClose = () => {\n      this.socket.log(\"channel\", `leave ${this.topic}`);\n      this._trigger(CHANNEL_EVENTS.close, \"leave\", this._joinRef());\n    };\n    this.rejoinTimer.reset();\n    this.joinPush.destroy();\n    return new Promise((resolve) => {\n      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive(\"ok\", () => {\n        onClose();\n        resolve(\"ok\");\n      }).receive(\"timeout\", () => {\n        onClose();\n        resolve(\"timed out\");\n      }).receive(\"error\", () => {\n        resolve(\"error\");\n      });\n      leavePush.send();\n      if (!this._canPush()) {\n        leavePush.trigger(\"ok\", {});\n      }\n    });\n  }\n  _push(event, payload, timeout = this.timeout) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n    }\n    let pushEvent = new Push(this, event, payload, timeout);\n    if (this._canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n    return pushEvent;\n  }\n  _onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  _isMember(topic) {\n    return this.topic === topic;\n  }\n  _joinRef() {\n    return this.joinPush.ref;\n  }\n  _trigger(type, payload, ref) {\n    var _a, _b;\n    const typeLower = type.toLocaleLowerCase();\n    const { close, error, leave, join } = CHANNEL_EVENTS;\n    const events = [close, error, leave, join];\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return;\n    }\n    let handledPayload = this._onMessage(typeLower, payload, ref);\n    if (payload && !handledPayload) {\n      throw \"channel onMessage callbacks must return the payload, modified or unmodified\";\n    }\n    if ([\"insert\", \"update\", \"delete\"].includes(typeLower)) {\n      (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind) => {\n        var _a2, _b2, _c;\n        return ((_a2 = bind.filter) === null || _a2 === void 0 ? void 0 : _a2.event) === \"*\" || ((_c = (_b2 = bind.filter) === null || _b2 === void 0 ? void 0 : _b2.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n      }).map((bind) => bind.callback(handledPayload, ref));\n    } else {\n      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {\n        var _a2, _b2, _c, _d, _e, _f;\n        if ([\"broadcast\", \"presence\", \"postgres_changes\"].includes(typeLower)) {\n          if (\"id\" in bind) {\n            const bindId = bind.id;\n            const bindEvent = (_a2 = bind.filter) === null || _a2 === void 0 ? void 0 : _a2.event;\n            return bindId && ((_b2 = payload.ids) === null || _b2 === void 0 ? void 0 : _b2.includes(bindId)) && (bindEvent === \"*\" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));\n          } else {\n            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n            return bindEvent === \"*\" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n          }\n        } else {\n          return bind.type.toLocaleLowerCase() === typeLower;\n        }\n      }).map((bind) => {\n        if (typeof handledPayload === \"object\" && \"ids\" in handledPayload) {\n          const postgresChanges = handledPayload.data;\n          const { schema, table, commit_timestamp, type: type2, errors } = postgresChanges;\n          const enrichedPayload = {\n            schema,\n            table,\n            commit_timestamp,\n            eventType: type2,\n            new: {},\n            old: {},\n            errors\n          };\n          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n        }\n        bind.callback(handledPayload, ref);\n      });\n    }\n  }\n  _isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  _isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  _isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  _isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n  _replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  _on(type, filter, callback) {\n    const typeLower = type.toLocaleLowerCase();\n    const binding = {\n      type: typeLower,\n      filter,\n      callback\n    };\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding);\n    } else {\n      this.bindings[typeLower] = [binding];\n    }\n    return this;\n  }\n  _off(type, filter) {\n    const typeLower = type.toLocaleLowerCase();\n    this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n      var _a;\n      return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n    });\n    return this;\n  }\n  static isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false;\n    }\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout();\n    if (this.socket.isConnected()) {\n      this._rejoin();\n    }\n  }\n  _onClose(callback) {\n    this._on(CHANNEL_EVENTS.close, {}, callback);\n  }\n  _onError(callback) {\n    this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));\n  }\n  _canPush() {\n    return this.socket.isConnected() && this._isJoined();\n  }\n  _rejoin(timeout = this.timeout) {\n    if (this._isLeaving()) {\n      return;\n    }\n    this.socket._leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  _getPayloadRecords(payload) {\n    const records = {\n      new: {},\n      old: {}\n    };\n    if (payload.type === \"INSERT\" || payload.type === \"UPDATE\") {\n      records.new = convertChangeData(payload.columns, payload.record);\n    }\n    if (payload.type === \"UPDATE\" || payload.type === \"DELETE\") {\n      records.old = convertChangeData(payload.columns, payload.old_record);\n    }\n    return records;\n  }\n};\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\nvar __awaiter5 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar noop2 = () => {\n};\nvar RealtimeClient = class {\n  constructor(endPoint, options) {\n    var _a;\n    this.accessToken = null;\n    this.channels = [];\n    this.endPoint = \"\";\n    this.headers = DEFAULT_HEADERS2;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = import_websocket.w3cwebsocket;\n    this.heartbeatIntervalMs = 3e4;\n    this.heartbeatTimer = void 0;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop2;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.eventsPerSecondLimitMs = 100;\n    this.inThrottle = false;\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    if (options === null || options === void 0 ? void 0 : options.params)\n      this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers)\n      this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout)\n      this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger)\n      this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.transport)\n      this.transport = options.transport;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    const eventsPerSecond = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.eventsPerSecond;\n    if (eventsPerSecond)\n      this.eventsPerSecondLimitMs = Math.floor(1e3 / eventsPerSecond);\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : (tries) => {\n      return [1e3, 2e3, 5e3, 1e4][tries - 1] || 1e4;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer(() => __awaiter5(this, void 0, void 0, function* () {\n      this.disconnect();\n      this.connect();\n    }), this.reconnectAfterMs);\n  }\n  connect() {\n    if (this.conn) {\n      return;\n    }\n    this.conn = new this.transport(this._endPointURL(), [], null, this.headers);\n    if (this.conn) {\n      this.conn.binaryType = \"arraybuffer\";\n      this.conn.onopen = () => this._onConnOpen();\n      this.conn.onerror = (error) => this._onConnError(error);\n      this.conn.onmessage = (event) => this._onConnMessage(event);\n      this.conn.onclose = (event) => this._onConnClose(event);\n    }\n  }\n  disconnect(code, reason) {\n    if (this.conn) {\n      this.conn.onclose = function() {\n      };\n      if (code) {\n        this.conn.close(code, reason !== null && reason !== void 0 ? reason : \"\");\n      } else {\n        this.conn.close();\n      }\n      this.conn = null;\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.reset();\n    }\n  }\n  getChannels() {\n    return this.channels;\n  }\n  removeChannel(channel) {\n    return channel.unsubscribe().then((status) => {\n      if (this.channels.length === 0) {\n        this.disconnect();\n      }\n      return status;\n    });\n  }\n  removeAllChannels() {\n    return Promise.all(this.channels.map((channel) => channel.unsubscribe())).then((values) => {\n      this.disconnect();\n      return values;\n    });\n  }\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting;\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open;\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing;\n      default:\n        return CONNECTION_STATE.Closed;\n    }\n  }\n  isConnected() {\n    return this.connectionState() === CONNECTION_STATE.Open;\n  }\n  channel(topic, params = { config: {} }) {\n    if (!this.isConnected()) {\n      this.connect();\n    }\n    const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n    this.channels.push(chan);\n    return chan;\n  }\n  push(data) {\n    const { topic, event, payload, ref } = data;\n    let callback = () => {\n      this.encode(data, (result) => {\n        var _a;\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n      });\n    };\n    this.log(\"push\", `${topic} ${event} (${ref})`, payload);\n    if (this.isConnected()) {\n      if ([\"broadcast\", \"presence\", \"postgres_changes\"].includes(event)) {\n        const isThrottled = this._throttle(callback)();\n        if (isThrottled) {\n          return \"rate limited\";\n        }\n      } else {\n        callback();\n      }\n    } else {\n      this.sendBuffer.push(callback);\n    }\n  }\n  setAuth(token) {\n    this.accessToken = token;\n    this.channels.forEach((channel) => {\n      token && channel.updateJoinPayload({ access_token: token });\n      if (channel.joinedOnce && channel._isJoined()) {\n        channel._push(CHANNEL_EVENTS.access_token, { access_token: token });\n      }\n    });\n  }\n  _makeRef() {\n    let newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n    return this.ref.toString();\n  }\n  _leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));\n    if (dupChannel) {\n      this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n      dupChannel.unsubscribe();\n    }\n  }\n  _remove(channel) {\n    this.channels = this.channels.filter((c) => c._joinRef() !== channel._joinRef());\n  }\n  _endPointURL() {\n    return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));\n  }\n  _onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, (msg) => {\n      let { topic, event, payload, ref } = msg;\n      if (ref && ref === this.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n        this.pendingHeartbeatRef = null;\n      }\n      this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload);\n      this.channels.filter((channel) => channel._isMember(topic)).forEach((channel) => channel._trigger(event, payload, ref));\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg));\n    });\n  }\n  _onConnOpen() {\n    this.log(\"transport\", `connected to ${this._endPointURL()}`);\n    this._flushSendBuffer();\n    this.reconnectTimer.reset();\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);\n    this.stateChangeCallbacks.open.forEach((callback) => callback());\n  }\n  _onConnClose(event) {\n    this.log(\"transport\", \"close\", event);\n    this._triggerChanError();\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.reconnectTimer.scheduleTimeout();\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event));\n  }\n  _onConnError(error) {\n    this.log(\"transport\", error.message);\n    this._triggerChanError();\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error));\n  }\n  _triggerChanError() {\n    this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));\n  }\n  _appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n    const prefix = url.match(/\\?/) ? \"&\" : \"?\";\n    const query = new URLSearchParams(params);\n    return `${url}${prefix}${query}`;\n  }\n  _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback());\n      this.sendBuffer = [];\n    }\n  }\n  _sendHeartbeat() {\n    var _a;\n    if (!this.isConnected()) {\n      return;\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n      (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, \"hearbeat timeout\");\n      return;\n    }\n    this.pendingHeartbeatRef = this._makeRef();\n    this.push({\n      topic: \"phoenix\",\n      event: \"heartbeat\",\n      payload: {},\n      ref: this.pendingHeartbeatRef\n    });\n    this.setAuth(this.accessToken);\n  }\n  _throttle(callback, eventsPerSecondLimit = this.eventsPerSecondLimitMs) {\n    return () => {\n      if (this.inThrottle)\n        return true;\n      callback();\n      this.inThrottle = true;\n      setTimeout(() => {\n        this.inThrottle = false;\n      }, eventsPerSecondLimit);\n      return false;\n    };\n  }\n};\n\n// node_modules/.pnpm/@supabase+storage-js@2.0.0/node_modules/@supabase/storage-js/dist/module/lib/errors.js\nvar StorageError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.__isStorageError = true;\n    this.name = \"StorageError\";\n  }\n};\nfunction isStorageError(error) {\n  return typeof error === \"object\" && error !== null && \"__isStorageError\" in error;\n}\nvar StorageApiError = class extends StorageError {\n  constructor(message, status) {\n    super(message);\n    this.name = \"StorageApiError\";\n    this.status = status;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status\n    };\n  }\n};\nvar StorageUnknownError = class extends StorageError {\n  constructor(message, originalError) {\n    super(message);\n    this.name = \"StorageUnknownError\";\n    this.originalError = originalError;\n  }\n};\n\n// node_modules/.pnpm/@supabase+storage-js@2.0.0/node_modules/@supabase/storage-js/dist/module/lib/helpers.js\nvar __awaiter6 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar resolveFetch2 = (customFetch) => {\n  let _fetch;\n  if (customFetch) {\n    _fetch = customFetch;\n  } else if (typeof fetch === \"undefined\") {\n    _fetch = (...args) => __awaiter6(void 0, void 0, void 0, function* () {\n      return yield (yield import(\"./browser-ponyfill-T7ISBDOE.js\")).fetch(...args);\n    });\n  } else {\n    _fetch = fetch;\n  }\n  return (...args) => _fetch(...args);\n};\nvar resolveResponse = () => __awaiter6(void 0, void 0, void 0, function* () {\n  if (typeof Response === \"undefined\") {\n    return (yield import(\"./browser-ponyfill-T7ISBDOE.js\")).Response;\n  }\n  return Response;\n});\n\n// node_modules/.pnpm/@supabase+storage-js@2.0.0/node_modules/@supabase/storage-js/dist/module/lib/fetch.js\nvar __awaiter7 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nvar handleError = (error, reject) => __awaiter7(void 0, void 0, void 0, function* () {\n  const Res = yield resolveResponse();\n  if (error instanceof Res) {\n    error.json().then((err) => {\n      reject(new StorageApiError(_getErrorMessage(err), error.status || 500));\n    });\n  } else {\n    reject(new StorageUnknownError(_getErrorMessage(error), error));\n  }\n});\nvar _getRequestParams = (method, options, parameters, body) => {\n  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };\n  if (method === \"GET\") {\n    return params;\n  }\n  params.headers = Object.assign({ \"Content-Type\": \"application/json\" }, options === null || options === void 0 ? void 0 : options.headers);\n  params.body = JSON.stringify(body);\n  return Object.assign(Object.assign({}, params), parameters);\n};\nfunction _handleRequest(fetcher, method, url, options, parameters, body) {\n  return __awaiter7(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      fetcher(url, _getRequestParams(method, options, parameters, body)).then((result) => {\n        if (!result.ok)\n          throw result;\n        if (options === null || options === void 0 ? void 0 : options.noResolveJson)\n          return result;\n        return result.json();\n      }).then((data) => resolve(data)).catch((error) => handleError(error, reject));\n    });\n  });\n}\nfunction get(fetcher, url, options, parameters) {\n  return __awaiter7(this, void 0, void 0, function* () {\n    return _handleRequest(fetcher, \"GET\", url, options, parameters);\n  });\n}\nfunction post(fetcher, url, body, options, parameters) {\n  return __awaiter7(this, void 0, void 0, function* () {\n    return _handleRequest(fetcher, \"POST\", url, options, parameters, body);\n  });\n}\nfunction put(fetcher, url, body, options, parameters) {\n  return __awaiter7(this, void 0, void 0, function* () {\n    return _handleRequest(fetcher, \"PUT\", url, options, parameters, body);\n  });\n}\nfunction remove(fetcher, url, body, options, parameters) {\n  return __awaiter7(this, void 0, void 0, function* () {\n    return _handleRequest(fetcher, \"DELETE\", url, options, parameters, body);\n  });\n}\n\n// node_modules/.pnpm/@supabase+storage-js@2.0.0/node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js\nvar __awaiter8 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar DEFAULT_SEARCH_OPTIONS = {\n  limit: 100,\n  offset: 0,\n  sortBy: {\n    column: \"name\",\n    order: \"asc\"\n  }\n};\nvar DEFAULT_FILE_OPTIONS = {\n  cacheControl: \"3600\",\n  contentType: \"text/plain;charset=UTF-8\",\n  upsert: false\n};\nvar StorageFileApi = class {\n  constructor(url, headers = {}, bucketId, fetch2) {\n    this.url = url;\n    this.headers = headers;\n    this.bucketId = bucketId;\n    this.fetch = resolveFetch2(fetch2);\n  }\n  uploadOrUpdate(method, path, fileBody, fileOptions) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      try {\n        let body;\n        const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);\n        const headers = Object.assign(Object.assign({}, this.headers), method === \"POST\" && { \"x-upsert\": String(options.upsert) });\n        if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n          body = new FormData();\n          body.append(\"cacheControl\", options.cacheControl);\n          body.append(\"\", fileBody);\n        } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n          body = fileBody;\n          body.append(\"cacheControl\", options.cacheControl);\n        } else {\n          body = fileBody;\n          headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n          headers[\"content-type\"] = options.contentType;\n        }\n        const cleanPath = this._removeEmptyFolders(path);\n        const _path = this._getFinalPath(cleanPath);\n        const res = yield this.fetch(`${this.url}/object/${_path}`, {\n          method,\n          body,\n          headers\n        });\n        if (res.ok) {\n          return {\n            data: { path: cleanPath },\n            error: null\n          };\n        } else {\n          const error = yield res.json();\n          return { data: null, error };\n        }\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  upload(path, fileBody, fileOptions) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      return this.uploadOrUpdate(\"POST\", path, fileBody, fileOptions);\n    });\n  }\n  update(path, fileBody, fileOptions) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      return this.uploadOrUpdate(\"PUT\", path, fileBody, fileOptions);\n    });\n  }\n  move(fromPath, toPath) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/object/move`, { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath }, { headers: this.headers });\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  copy(fromPath, toPath) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/object/copy`, { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath }, { headers: this.headers });\n        return { data: { path: data.Key }, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  createSignedUrl(path, expiresIn, options) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      try {\n        const _path = this._getFinalPath(path);\n        let data = yield post(this.fetch, `${this.url}/object/sign/${_path}`, { expiresIn }, { headers: this.headers });\n        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n        const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);\n        data = { signedUrl };\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  createSignedUrls(paths, expiresIn, options) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });\n        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n        return {\n          data: data.map((datum) => Object.assign(Object.assign({}, datum), { signedUrl: datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null })),\n          error: null\n        };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  download(path) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      try {\n        const _path = this._getFinalPath(path);\n        const res = yield get(this.fetch, `${this.url}/object/${_path}`, {\n          headers: this.headers,\n          noResolveJson: true\n        });\n        const data = yield res.blob();\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  getPublicUrl(path, options) {\n    const _path = this._getFinalPath(path);\n    const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `?download=${options.download === true ? \"\" : options.download}` : \"\";\n    return {\n      data: { publicUrl: encodeURI(`${this.url}/object/public/${_path}${downloadQueryParam}`) }\n    };\n  }\n  remove(paths) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      try {\n        const data = yield remove(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  list(path, options, parameters) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      try {\n        const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || \"\" });\n        const data = yield post(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, { headers: this.headers }, parameters);\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  _getFinalPath(path) {\n    return `${this.bucketId}/${path}`;\n  }\n  _removeEmptyFolders(path) {\n    return path.replace(/^\\/|\\/$/g, \"\").replace(/\\/+/g, \"/\");\n  }\n};\n\n// node_modules/.pnpm/@supabase+storage-js@2.0.0/node_modules/@supabase/storage-js/dist/module/lib/version.js\nvar version3 = \"2.0.0\";\n\n// node_modules/.pnpm/@supabase+storage-js@2.0.0/node_modules/@supabase/storage-js/dist/module/lib/constants.js\nvar DEFAULT_HEADERS3 = { \"X-Client-Info\": `storage-js/${version3}` };\n\n// node_modules/.pnpm/@supabase+storage-js@2.0.0/node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js\nvar __awaiter9 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar StorageBucketApi = class {\n  constructor(url, headers = {}, fetch2) {\n    this.url = url;\n    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS3), headers);\n    this.fetch = resolveFetch2(fetch2);\n  }\n  listBuckets() {\n    return __awaiter9(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/bucket`, { headers: this.headers });\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  getBucket(id) {\n    return __awaiter9(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers });\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  createBucket(id, options = { public: false }) {\n    return __awaiter9(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/bucket`, { id, name: id, public: options.public }, { headers: this.headers });\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  updateBucket(id, options) {\n    return __awaiter9(this, void 0, void 0, function* () {\n      try {\n        const data = yield put(this.fetch, `${this.url}/bucket/${id}`, { id, name: id, public: options.public }, { headers: this.headers });\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  emptyBucket(id) {\n    return __awaiter9(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  deleteBucket(id) {\n    return __awaiter9(this, void 0, void 0, function* () {\n      try {\n        const data = yield remove(this.fetch, `${this.url}/bucket/${id}`, {}, { headers: this.headers });\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n};\n\n// node_modules/.pnpm/@supabase+storage-js@2.0.0/node_modules/@supabase/storage-js/dist/module/StorageClient.js\nvar StorageClient = class extends StorageBucketApi {\n  constructor(url, headers = {}, fetch2) {\n    super(url, headers, fetch2);\n  }\n  from(id) {\n    return new StorageFileApi(this.url, this.headers, id, this.fetch);\n  }\n};\n\n// node_modules/.pnpm/@supabase+supabase-js@2.1.0/node_modules/@supabase/supabase-js/dist/module/lib/version.js\nvar version4 = \"2.1.0\";\n\n// node_modules/.pnpm/@supabase+supabase-js@2.1.0/node_modules/@supabase/supabase-js/dist/module/lib/constants.js\nvar DEFAULT_HEADERS4 = { \"X-Client-Info\": `supabase-js/${version4}` };\n\n// node_modules/.pnpm/@supabase+supabase-js@2.1.0/node_modules/@supabase/supabase-js/dist/module/lib/fetch.js\nvar import_cross_fetch2 = __toESM(require_browser_ponyfill());\nvar __awaiter10 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar resolveFetch3 = (customFetch) => {\n  let _fetch;\n  if (customFetch) {\n    _fetch = customFetch;\n  } else if (typeof fetch === \"undefined\") {\n    _fetch = import_cross_fetch2.default;\n  } else {\n    _fetch = fetch;\n  }\n  return (...args) => _fetch(...args);\n};\nvar resolveHeadersConstructor = () => {\n  if (typeof Headers === \"undefined\") {\n    return import_cross_fetch2.Headers;\n  }\n  return Headers;\n};\nvar fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {\n  const fetch2 = resolveFetch3(customFetch);\n  const HeadersConstructor = resolveHeadersConstructor();\n  return (input, init) => __awaiter10(void 0, void 0, void 0, function* () {\n    var _a;\n    const accessToken = (_a = yield getAccessToken()) !== null && _a !== void 0 ? _a : supabaseKey;\n    let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n    if (!headers.has(\"apikey\")) {\n      headers.set(\"apikey\", supabaseKey);\n    }\n    if (!headers.has(\"Authorization\")) {\n      headers.set(\"Authorization\", `Bearer ${accessToken}`);\n    }\n    return fetch2(input, Object.assign(Object.assign({}, init), { headers }));\n  });\n};\n\n// node_modules/.pnpm/@supabase+supabase-js@2.1.0/node_modules/@supabase/supabase-js/dist/module/lib/helpers.js\nfunction stripTrailingSlash(url) {\n  return url.replace(/\\/$/, \"\");\n}\nfunction applySettingDefaults(options, defaults) {\n  const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;\n  const { db: DEFAULT_DB_OPTIONS2, auth: DEFAULT_AUTH_OPTIONS2, realtime: DEFAULT_REALTIME_OPTIONS2, global: DEFAULT_GLOBAL_OPTIONS2 } = defaults;\n  return {\n    db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS2), dbOptions),\n    auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS2), authOptions),\n    realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS2), realtimeOptions),\n    global: Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS2), globalOptions)\n  };\n}\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/lib/helpers.js\nvar __awaiter11 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nfunction expiresAt(expiresIn) {\n  const timeNow = Math.round(Date.now() / 1e3);\n  return timeNow + expiresIn;\n}\nfunction uuid() {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 3 | 8;\n    return v.toString(16);\n  });\n}\nvar isBrowser = () => typeof window !== \"undefined\";\nfunction getParameterByName(name, url) {\n  var _a;\n  if (!url)\n    url = ((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.href) || \"\";\n  name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n  const regex = new RegExp(\"[?&#]\" + name + \"(=([^&#]*)|&|#|$)\"), results = regex.exec(url);\n  if (!results)\n    return null;\n  if (!results[2])\n    return \"\";\n  return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n}\nvar resolveFetch4 = (customFetch) => {\n  let _fetch;\n  if (customFetch) {\n    _fetch = customFetch;\n  } else if (typeof fetch === \"undefined\") {\n    _fetch = (...args) => __awaiter11(void 0, void 0, void 0, function* () {\n      return yield (yield import(\"./browser-ponyfill-T7ISBDOE.js\")).fetch(...args);\n    });\n  } else {\n    _fetch = fetch;\n  }\n  return (...args) => _fetch(...args);\n};\nvar looksLikeFetchResponse = (maybeResponse) => {\n  return typeof maybeResponse === \"object\" && maybeResponse !== null && \"status\" in maybeResponse && \"ok\" in maybeResponse && \"json\" in maybeResponse && typeof maybeResponse.json === \"function\";\n};\nvar setItemAsync = (storage, key, data) => __awaiter11(void 0, void 0, void 0, function* () {\n  yield storage.setItem(key, JSON.stringify(data));\n});\nvar getItemAsync = (storage, key) => __awaiter11(void 0, void 0, void 0, function* () {\n  const value = yield storage.getItem(key);\n  if (!value) {\n    return null;\n  }\n  try {\n    return JSON.parse(value);\n  } catch (_a) {\n    return value;\n  }\n});\nvar removeItemAsync = (storage, key) => __awaiter11(void 0, void 0, void 0, function* () {\n  yield storage.removeItem(key);\n});\nvar decodeBase64URL = (value) => {\n  try {\n    return decodeURIComponent(atob(value.replace(/[-]/g, \"+\").replace(/[_]/g, \"/\")).split(\"\").map((c) => \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2)).join(\"\"));\n  } catch (e) {\n    if (e instanceof ReferenceError) {\n      return Buffer.from(value, \"base64\").toString(\"utf-8\");\n    } else {\n      throw e;\n    }\n  }\n};\nvar Deferred = class {\n  constructor() {\n    ;\n    this.promise = new Deferred.promiseConstructor((res, rej) => {\n      ;\n      this.resolve = res;\n      this.reject = rej;\n    });\n  }\n};\nDeferred.promiseConstructor = Promise;\nfunction decodeJWTPayload(token) {\n  const parts = token.split(\".\");\n  if (parts.length !== 3) {\n    throw new Error(\"JWT is not valid: not a JWT structure\");\n  }\n  const base64Url = parts[1];\n  return JSON.parse(decodeBase64URL(base64Url));\n}\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/lib/errors.js\nvar AuthError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.__isAuthError = true;\n    this.name = \"AuthError\";\n  }\n};\nfunction isAuthError(error) {\n  return typeof error === \"object\" && error !== null && \"__isAuthError\" in error;\n}\nvar AuthApiError = class extends AuthError {\n  constructor(message, status) {\n    super(message);\n    this.name = \"AuthApiError\";\n    this.status = status;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status\n    };\n  }\n};\nvar AuthUnknownError = class extends AuthError {\n  constructor(message, originalError) {\n    super(message);\n    this.name = \"AuthUnknownError\";\n    this.originalError = originalError;\n  }\n};\nvar CustomAuthError = class extends AuthError {\n  constructor(message, name, status) {\n    super(message);\n    this.name = name;\n    this.status = status;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status\n    };\n  }\n};\nvar AuthSessionMissingError = class extends CustomAuthError {\n  constructor() {\n    super(\"Auth session missing!\", \"AuthSessionMissingError\", 400);\n  }\n};\nvar AuthInvalidCredentialsError = class extends CustomAuthError {\n  constructor(message) {\n    super(message, \"AuthInvalidCredentialsError\", 400);\n  }\n};\nvar AuthImplicitGrantRedirectError = class extends CustomAuthError {\n  constructor(message, details = null) {\n    super(message, \"AuthImplicitGrantRedirectError\", 500);\n    this.details = null;\n    this.details = details;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n      details: this.details\n    };\n  }\n};\nvar AuthRetryableFetchError = class extends CustomAuthError {\n  constructor(message, status) {\n    super(message, \"AuthRetryableFetchError\", status);\n  }\n};\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/lib/fetch.js\nvar __awaiter12 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = function(s, e) {\n  var t = {};\n  for (var p in s)\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n        t[p[i]] = s[p[i]];\n    }\n  return t;\n};\nvar _getErrorMessage2 = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nvar handleError2 = (error, reject) => __awaiter12(void 0, void 0, void 0, function* () {\n  const NETWORK_ERROR_CODES = [502, 503, 504];\n  if (!looksLikeFetchResponse(error)) {\n    reject(new AuthRetryableFetchError(_getErrorMessage2(error), 0));\n  } else if (NETWORK_ERROR_CODES.includes(error.status)) {\n    reject(new AuthRetryableFetchError(_getErrorMessage2(error), error.status));\n  } else {\n    error.json().then((err) => {\n      reject(new AuthApiError(_getErrorMessage2(err), error.status || 500));\n    }).catch((e) => {\n      reject(new AuthUnknownError(_getErrorMessage2(e), e));\n    });\n  }\n});\nvar _getRequestParams2 = (method, options, parameters, body) => {\n  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };\n  if (method === \"GET\") {\n    return params;\n  }\n  params.headers = Object.assign({ \"Content-Type\": \"application/json;charset=UTF-8\" }, options === null || options === void 0 ? void 0 : options.headers);\n  params.body = JSON.stringify(body);\n  return Object.assign(Object.assign({}, params), parameters);\n};\nfunction _request(fetcher, method, url, options) {\n  var _a, _b;\n  return __awaiter12(this, void 0, void 0, function* () {\n    const headers = (_a = options === null || options === void 0 ? void 0 : options.headers) !== null && _a !== void 0 ? _a : {};\n    if (options === null || options === void 0 ? void 0 : options.jwt) {\n      headers[\"Authorization\"] = `Bearer ${options.jwt}`;\n    }\n    const qs = (_b = options === null || options === void 0 ? void 0 : options.query) !== null && _b !== void 0 ? _b : {};\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n      qs[\"redirect_to\"] = options.redirectTo;\n    }\n    const queryString = Object.keys(qs).length ? \"?\" + new URLSearchParams(qs).toString() : \"\";\n    const data = yield _handleRequest2(fetcher, method, url + queryString, { headers, noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson }, {}, options === null || options === void 0 ? void 0 : options.body);\n    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };\n  });\n}\nfunction _handleRequest2(fetcher, method, url, options, parameters, body) {\n  return __awaiter12(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      fetcher(url, _getRequestParams2(method, options, parameters, body)).then((result) => {\n        if (!result.ok)\n          throw result;\n        if (options === null || options === void 0 ? void 0 : options.noResolveJson)\n          return result;\n        return result.json();\n      }).then((data) => resolve(data)).catch((error) => handleError2(error, reject));\n    });\n  });\n}\nfunction _sessionResponse(data) {\n  var _a;\n  let session = null;\n  if (hasSession(data)) {\n    session = Object.assign({}, data);\n    session.expires_at = expiresAt(data.expires_in);\n  }\n  const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n  return { data: { session, user }, error: null };\n}\nfunction _userResponse(data) {\n  var _a;\n  const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n  return { data: { user }, error: null };\n}\nfunction _ssoResponse(data) {\n  return { data, error: null };\n}\nfunction _generateLinkResponse(data) {\n  const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, [\"action_link\", \"email_otp\", \"hashed_token\", \"redirect_to\", \"verification_type\"]);\n  const properties = {\n    action_link,\n    email_otp,\n    hashed_token,\n    redirect_to,\n    verification_type\n  };\n  const user = Object.assign({}, rest);\n  return {\n    data: {\n      properties,\n      user\n    },\n    error: null\n  };\n}\nfunction hasSession(data) {\n  return data.access_token && data.refresh_token && data.expires_in;\n}\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/GoTrueAdminApi.js\nvar __awaiter13 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest2 = function(s, e) {\n  var t = {};\n  for (var p in s)\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n        t[p[i]] = s[p[i]];\n    }\n  return t;\n};\nvar GoTrueAdminApi = class {\n  constructor({ url = \"\", headers = {}, fetch: fetch2 }) {\n    this.url = url;\n    this.headers = headers;\n    this.fetch = resolveFetch4(fetch2);\n    this.mfa = {\n      listFactors: this._listFactors.bind(this),\n      deleteFactor: this._deleteFactor.bind(this)\n    };\n  }\n  signOut(jwt) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        yield _request(this.fetch, \"POST\", `${this.url}/logout`, {\n          headers: this.headers,\n          jwt,\n          noResolveJson: true\n        });\n        return { data: null, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  inviteUserByEmail(email, options = {}) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, \"POST\", `${this.url}/invite`, {\n          body: { email, data: options.data },\n          headers: this.headers,\n          redirectTo: options.redirectTo,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  generateLink(params) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        const { options } = params, rest = __rest2(params, [\"options\"]);\n        const body = Object.assign(Object.assign({}, rest), options);\n        if (\"newEmail\" in rest) {\n          body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;\n          delete body[\"newEmail\"];\n        }\n        return yield _request(this.fetch, \"POST\", `${this.url}/admin/generate_link`, {\n          body,\n          headers: this.headers,\n          xform: _generateLinkResponse,\n          redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              properties: null,\n              user: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  createUser(attributes) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, \"POST\", `${this.url}/admin/users`, {\n          body: attributes,\n          headers: this.headers,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  listUsers() {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        const { data, error } = yield _request(this.fetch, \"GET\", `${this.url}/admin/users`, {\n          headers: this.headers\n        });\n        if (error)\n          throw error;\n        return { data: Object.assign({}, data), error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { users: [] }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  getUserById(uid) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, \"GET\", `${this.url}/admin/users/${uid}`, {\n          headers: this.headers,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  updateUserById(uid, attributes) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, \"PUT\", `${this.url}/admin/users/${uid}`, {\n          body: attributes,\n          headers: this.headers,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  deleteUser(id) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, \"DELETE\", `${this.url}/admin/users/${id}`, {\n          headers: this.headers,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  _listFactors(params) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        const data = yield _request(this.fetch, \"GET\", `${this.url}/admin/users/${params.userId}/factors`, {\n          headers: this.headers\n        });\n        return { data, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  _deleteFactor(params) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        const data = yield _request(this.fetch, \"DELETE\", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {\n          headers: this.headers\n        });\n        return { data, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n};\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/lib/version.js\nvar version5 = \"2.3.0\";\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/lib/constants.js\nvar GOTRUE_URL = \"http://localhost:9999\";\nvar STORAGE_KEY = \"supabase.auth.token\";\nvar DEFAULT_HEADERS5 = { \"X-Client-Info\": `gotrue-js/${version5}` };\nvar EXPIRY_MARGIN = 10;\nvar NETWORK_FAILURE = {\n  MAX_RETRIES: 10,\n  RETRY_INTERVAL: 2\n};\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/lib/local-storage.js\nvar localStorageAdapter = {\n  getItem: (key) => {\n    if (!isBrowser()) {\n      return null;\n    }\n    return globalThis.localStorage.getItem(key);\n  },\n  setItem: (key, value) => {\n    if (!isBrowser()) {\n      return;\n    }\n    globalThis.localStorage.setItem(key, value);\n  },\n  removeItem: (key) => {\n    if (!isBrowser()) {\n      return;\n    }\n    globalThis.localStorage.removeItem(key);\n  }\n};\nvar local_storage_default = localStorageAdapter;\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/lib/polyfills.js\nfunction polyfillGlobalThis() {\n  if (typeof globalThis === \"object\")\n    return;\n  try {\n    Object.defineProperty(Object.prototype, \"__magic__\", {\n      get: function() {\n        return this;\n      },\n      configurable: true\n    });\n    __magic__.globalThis = __magic__;\n    delete Object.prototype.__magic__;\n  } catch (e) {\n    if (typeof self !== \"undefined\") {\n      self.globalThis = self;\n    }\n  }\n}\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/GoTrueClient.js\nvar __awaiter14 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\npolyfillGlobalThis();\nvar DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS5\n};\nvar GoTrueClient = class {\n  constructor(options) {\n    this.stateChangeEmitters = /* @__PURE__ */ new Map();\n    this.networkRetries = 0;\n    this.refreshingDeferred = null;\n    this.initializePromise = null;\n    this.detectSessionInUrl = true;\n    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.inMemorySession = null;\n    this.storageKey = settings.storageKey;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.storage = settings.storage || local_storage_default;\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch\n    });\n    this.url = settings.url;\n    this.headers = settings.headers;\n    this.fetch = resolveFetch4(settings.fetch);\n    this.detectSessionInUrl = settings.detectSessionInUrl;\n    this.initialize();\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)\n    };\n  }\n  initialize() {\n    if (!this.initializePromise) {\n      this.initializePromise = this._initialize();\n    }\n    return this.initializePromise;\n  }\n  _initialize() {\n    return __awaiter14(this, void 0, void 0, function* () {\n      if (this.initializePromise) {\n        return this.initializePromise;\n      }\n      try {\n        if (this.detectSessionInUrl && this._isImplicitGrantFlow()) {\n          const { data, error } = yield this._getSessionFromUrl();\n          if (error) {\n            yield this._removeSession();\n            return { error };\n          }\n          const { session, redirectType } = data;\n          yield this._saveSession(session);\n          this._notifyAllSubscribers(\"SIGNED_IN\", session);\n          if (redirectType === \"recovery\") {\n            this._notifyAllSubscribers(\"PASSWORD_RECOVERY\", session);\n          }\n          return { error: null };\n        }\n        yield this._recoverAndRefresh();\n        return { error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { error };\n        }\n        return {\n          error: new AuthUnknownError(\"Unexpected error during initialization\", error)\n        };\n      } finally {\n        this._handleVisibilityChange();\n      }\n    });\n  }\n  signUp(credentials) {\n    var _a, _b;\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        let res;\n        if (\"email\" in credentials) {\n          const { email, password, options } = credentials;\n          res = yield _request(this.fetch, \"POST\", `${this.url}/signup`, {\n            headers: this.headers,\n            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n            body: {\n              email,\n              password,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }\n            },\n            xform: _sessionResponse\n          });\n        } else if (\"phone\" in credentials) {\n          const { phone, password, options } = credentials;\n          res = yield _request(this.fetch, \"POST\", `${this.url}/signup`, {\n            headers: this.headers,\n            body: {\n              phone,\n              password,\n              data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }\n            },\n            xform: _sessionResponse\n          });\n        } else {\n          throw new AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n        }\n        const { data, error } = res;\n        if (error || !data) {\n          return { data: { user: null, session: null }, error };\n        }\n        const session = data.session;\n        const user = data.user;\n        if (data.session) {\n          yield this._saveSession(data.session);\n          this._notifyAllSubscribers(\"SIGNED_IN\", session);\n        }\n        return { data: { user, session }, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null, session: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  signInWithPassword(credentials) {\n    var _a, _b;\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        let res;\n        if (\"email\" in credentials) {\n          const { email, password, options } = credentials;\n          res = yield _request(this.fetch, \"POST\", `${this.url}/token?grant_type=password`, {\n            headers: this.headers,\n            body: {\n              email,\n              password,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }\n            },\n            xform: _sessionResponse\n          });\n        } else if (\"phone\" in credentials) {\n          const { phone, password, options } = credentials;\n          res = yield _request(this.fetch, \"POST\", `${this.url}/token?grant_type=password`, {\n            headers: this.headers,\n            body: {\n              phone,\n              password,\n              data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }\n            },\n            xform: _sessionResponse\n          });\n        } else {\n          throw new AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n        }\n        const { data, error } = res;\n        if (error || !data)\n          return { data: { user: null, session: null }, error };\n        if (data.session) {\n          yield this._saveSession(data.session);\n          this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n        }\n        return { data, error };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null, session: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  signInWithOAuth(credentials) {\n    var _a, _b, _c;\n    return __awaiter14(this, void 0, void 0, function* () {\n      yield this._removeSession();\n      return this._handleProviderSignIn(credentials.provider, {\n        redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n        scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n        queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams\n      });\n    });\n  }\n  signInWithOtp(credentials) {\n    var _a, _b, _c, _d;\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        if (\"email\" in credentials) {\n          const { email, options } = credentials;\n          const { error } = yield _request(this.fetch, \"POST\", `${this.url}/otp`, {\n            headers: this.headers,\n            body: {\n              email,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }\n            },\n            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n          });\n          return { data: { user: null, session: null }, error };\n        }\n        if (\"phone\" in credentials) {\n          const { phone, options } = credentials;\n          const { error } = yield _request(this.fetch, \"POST\", `${this.url}/otp`, {\n            headers: this.headers,\n            body: {\n              phone,\n              data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n              create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }\n            }\n          });\n          return { data: { user: null, session: null }, error };\n        }\n        throw new AuthInvalidCredentialsError(\"You must provide either an email or phone number.\");\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null, session: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  verifyOtp(params) {\n    var _a, _b;\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        const { data, error } = yield _request(this.fetch, \"POST\", `${this.url}/verify`, {\n          headers: this.headers,\n          body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken } }),\n          redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n          xform: _sessionResponse\n        });\n        if (error) {\n          throw error;\n        }\n        if (!data) {\n          throw \"An error occurred on token verification.\";\n        }\n        const session = data.session;\n        const user = data.user;\n        if (session === null || session === void 0 ? void 0 : session.access_token) {\n          yield this._saveSession(session);\n          this._notifyAllSubscribers(\"SIGNED_IN\", session);\n        }\n        return { data: { user, session }, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null, session: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  signInWithSSO(params) {\n    var _a, _b, _c;\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        return yield _request(this.fetch, \"POST\", `${this.url}/sso`, {\n          body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, \"providerId\" in params ? { provider_id: params.providerId } : null), \"domain\" in params ? { domain: params.domain } : null), { redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : void 0 }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } } : null), { skip_http_redirect: true }),\n          headers: this.headers,\n          xform: _ssoResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  getSession() {\n    return __awaiter14(this, void 0, void 0, function* () {\n      yield this.initializePromise;\n      let currentSession = null;\n      if (this.persistSession) {\n        const maybeSession = yield getItemAsync(this.storage, this.storageKey);\n        if (maybeSession !== null) {\n          if (this._isValidSession(maybeSession)) {\n            currentSession = maybeSession;\n          } else {\n            yield this._removeSession();\n          }\n        }\n      } else {\n        currentSession = this.inMemorySession;\n      }\n      if (!currentSession) {\n        return { data: { session: null }, error: null };\n      }\n      const hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1e3 : false;\n      if (!hasExpired) {\n        return { data: { session: currentSession }, error: null };\n      }\n      const { session, error } = yield this._callRefreshToken(currentSession.refresh_token);\n      if (error) {\n        return { data: { session: null }, error };\n      }\n      return { data: { session }, error: null };\n    });\n  }\n  getUser(jwt) {\n    var _a, _b;\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        if (!jwt) {\n          const { data, error } = yield this.getSession();\n          if (error) {\n            throw error;\n          }\n          jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : void 0;\n        }\n        return yield _request(this.fetch, \"GET\", `${this.url}/user`, {\n          headers: this.headers,\n          jwt,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  updateUser(attributes) {\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        const { data: sessionData, error: sessionError } = yield this.getSession();\n        if (sessionError) {\n          throw sessionError;\n        }\n        if (!sessionData.session) {\n          throw new AuthSessionMissingError();\n        }\n        const session = sessionData.session;\n        const { data, error: userError } = yield _request(this.fetch, \"PUT\", `${this.url}/user`, {\n          headers: this.headers,\n          body: attributes,\n          jwt: session.access_token,\n          xform: _userResponse\n        });\n        if (userError)\n          throw userError;\n        session.user = data.user;\n        yield this._saveSession(session);\n        this._notifyAllSubscribers(\"USER_UPDATED\", session);\n        return { data: { user: session.user }, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  _decodeJWT(jwt) {\n    return decodeJWTPayload(jwt);\n  }\n  setSession(currentSession) {\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        const timeNow = Date.now() / 1e3;\n        let expiresAt2 = timeNow;\n        let hasExpired = true;\n        let session = null;\n        if (currentSession.access_token && currentSession.access_token.split(\".\")[1]) {\n          const payload = this._decodeJWT(currentSession.access_token);\n          if (payload.exp) {\n            expiresAt2 = payload.exp;\n            hasExpired = expiresAt2 <= timeNow;\n          }\n        }\n        if (hasExpired) {\n          if (!currentSession.refresh_token) {\n            throw new AuthSessionMissingError();\n          }\n          const { data, error } = yield this._refreshAccessToken(currentSession.refresh_token);\n          if (error) {\n            return { data: { session: null, user: null }, error };\n          }\n          if (!data.session) {\n            return { data: { session: null, user: null }, error: null };\n          }\n          session = data.session;\n        } else {\n          const { data, error } = yield this.getUser(currentSession.access_token);\n          if (error) {\n            throw error;\n          }\n          session = {\n            access_token: currentSession.access_token,\n            refresh_token: currentSession.refresh_token,\n            user: data.user,\n            token_type: \"bearer\",\n            expires_in: expiresAt2 - timeNow,\n            expires_at: expiresAt2\n          };\n        }\n        yield this._saveSession(session);\n        this._notifyAllSubscribers(\"TOKEN_REFRESHED\", session);\n        return { data: { session, user: session.user }, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { session: null, user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  refreshSession(currentSession) {\n    var _a;\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        if (!currentSession) {\n          const { data, error: error2 } = yield this.getSession();\n          if (error2) {\n            throw error2;\n          }\n          currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : void 0;\n        }\n        if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n          throw new AuthSessionMissingError();\n        }\n        const { session, error } = yield this._callRefreshToken(currentSession.refresh_token);\n        if (error) {\n          return { data: { user: null, session: null }, error };\n        }\n        if (!session) {\n          return { data: { user: null, session: null }, error: null };\n        }\n        return { data: { user: session.user, session }, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null, session: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  _getSessionFromUrl() {\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        if (!isBrowser())\n          throw new AuthImplicitGrantRedirectError(\"No browser detected.\");\n        if (!this._isImplicitGrantFlow()) {\n          throw new AuthImplicitGrantRedirectError(\"Not a valid implicit grant flow url.\");\n        }\n        const error_description = getParameterByName(\"error_description\");\n        if (error_description) {\n          const error_code = getParameterByName(\"error_code\");\n          if (!error_code)\n            throw new AuthImplicitGrantRedirectError(\"No error_code detected.\");\n          const error2 = getParameterByName(\"error\");\n          if (!error2)\n            throw new AuthImplicitGrantRedirectError(\"No error detected.\");\n          throw new AuthImplicitGrantRedirectError(error_description, { error: error2, code: error_code });\n        }\n        const provider_token = getParameterByName(\"provider_token\");\n        const provider_refresh_token = getParameterByName(\"provider_refresh_token\");\n        const access_token = getParameterByName(\"access_token\");\n        if (!access_token)\n          throw new AuthImplicitGrantRedirectError(\"No access_token detected.\");\n        const expires_in = getParameterByName(\"expires_in\");\n        if (!expires_in)\n          throw new AuthImplicitGrantRedirectError(\"No expires_in detected.\");\n        const refresh_token = getParameterByName(\"refresh_token\");\n        if (!refresh_token)\n          throw new AuthImplicitGrantRedirectError(\"No refresh_token detected.\");\n        const token_type = getParameterByName(\"token_type\");\n        if (!token_type)\n          throw new AuthImplicitGrantRedirectError(\"No token_type detected.\");\n        const timeNow = Math.round(Date.now() / 1e3);\n        const expires_at = timeNow + parseInt(expires_in);\n        const { data, error } = yield this.getUser(access_token);\n        if (error)\n          throw error;\n        const user = data.user;\n        const session = {\n          provider_token,\n          provider_refresh_token,\n          access_token,\n          expires_in: parseInt(expires_in),\n          expires_at,\n          refresh_token,\n          token_type,\n          user\n        };\n        const redirectType = getParameterByName(\"type\");\n        window.location.hash = \"\";\n        return { data: { session, redirectType }, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { session: null, redirectType: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  _isImplicitGrantFlow() {\n    return isBrowser() && (Boolean(getParameterByName(\"access_token\")) || Boolean(getParameterByName(\"error_description\")));\n  }\n  signOut() {\n    var _a;\n    return __awaiter14(this, void 0, void 0, function* () {\n      const { data, error: sessionError } = yield this.getSession();\n      if (sessionError) {\n        return { error: sessionError };\n      }\n      const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n      if (accessToken) {\n        const { error } = yield this.admin.signOut(accessToken);\n        if (error)\n          return { error };\n      }\n      yield this._removeSession();\n      this._notifyAllSubscribers(\"SIGNED_OUT\", null);\n      return { error: null };\n    });\n  }\n  onAuthStateChange(callback) {\n    const id = uuid();\n    const subscription = {\n      id,\n      callback,\n      unsubscribe: () => {\n        this.stateChangeEmitters.delete(id);\n      }\n    };\n    this.stateChangeEmitters.set(id, subscription);\n    return { data: { subscription } };\n  }\n  resetPasswordForEmail(email, options = {}) {\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, \"POST\", `${this.url}/recover`, {\n          body: { email, gotrue_meta_security: { captcha_token: options.captchaToken } },\n          headers: this.headers,\n          redirectTo: options.redirectTo\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  _refreshAccessToken(refreshToken) {\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, \"POST\", `${this.url}/token?grant_type=refresh_token`, {\n          body: { refresh_token: refreshToken },\n          headers: this.headers,\n          xform: _sessionResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { session: null, user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  _isValidSession(maybeSession) {\n    const isValidSession = typeof maybeSession === \"object\" && maybeSession !== null && \"access_token\" in maybeSession && \"refresh_token\" in maybeSession && \"expires_at\" in maybeSession;\n    return isValidSession;\n  }\n  _handleProviderSignIn(provider, options = {}) {\n    const url = this._getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams\n    });\n    if (isBrowser()) {\n      window.location.href = url;\n    }\n    return { data: { provider, url }, error: null };\n  }\n  _recoverAndRefresh() {\n    var _a;\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        const currentSession = yield getItemAsync(this.storage, this.storageKey);\n        if (!this._isValidSession(currentSession)) {\n          if (currentSession !== null) {\n            yield this._removeSession();\n          }\n          return;\n        }\n        const timeNow = Math.round(Date.now() / 1e3);\n        if (((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN) {\n          if (this.autoRefreshToken && currentSession.refresh_token) {\n            this.networkRetries++;\n            const { error } = yield this._callRefreshToken(currentSession.refresh_token);\n            if (error) {\n              console.log(error.message);\n              if (error instanceof AuthRetryableFetchError && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) {\n                if (this.refreshTokenTimer)\n                  clearTimeout(this.refreshTokenTimer);\n                this.refreshTokenTimer = setTimeout(\n                  () => this._recoverAndRefresh(),\n                  Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100\n                );\n                return;\n              }\n              yield this._removeSession();\n            }\n            this.networkRetries = 0;\n          } else {\n            yield this._removeSession();\n          }\n        } else {\n          if (this.persistSession) {\n            yield this._saveSession(currentSession);\n          }\n          this._notifyAllSubscribers(\"SIGNED_IN\", currentSession);\n        }\n      } catch (err) {\n        console.error(err);\n        return;\n      }\n    });\n  }\n  _callRefreshToken(refreshToken) {\n    var _a, _b;\n    return __awaiter14(this, void 0, void 0, function* () {\n      if (this.refreshingDeferred) {\n        return this.refreshingDeferred.promise;\n      }\n      try {\n        this.refreshingDeferred = new Deferred();\n        if (!refreshToken) {\n          throw new AuthSessionMissingError();\n        }\n        const { data, error } = yield this._refreshAccessToken(refreshToken);\n        if (error)\n          throw error;\n        if (!data.session)\n          throw new AuthSessionMissingError();\n        yield this._saveSession(data.session);\n        this._notifyAllSubscribers(\"TOKEN_REFRESHED\", data.session);\n        const result = { session: data.session, error: null };\n        this.refreshingDeferred.resolve(result);\n        return result;\n      } catch (error) {\n        if (isAuthError(error)) {\n          const result = { session: null, error };\n          (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n          return result;\n        }\n        (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n        throw error;\n      } finally {\n        this.refreshingDeferred = null;\n      }\n    });\n  }\n  _notifyAllSubscribers(event, session) {\n    this.stateChangeEmitters.forEach((x) => x.callback(event, session));\n  }\n  _saveSession(session) {\n    return __awaiter14(this, void 0, void 0, function* () {\n      if (!this.persistSession) {\n        this.inMemorySession = session;\n      }\n      const expiresAt2 = session.expires_at;\n      if (expiresAt2) {\n        const timeNow = Math.round(Date.now() / 1e3);\n        const expiresIn = expiresAt2 - timeNow;\n        const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n        this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1e3);\n      }\n      if (this.persistSession && session.expires_at) {\n        yield this._persistSession(session);\n      }\n    });\n  }\n  _persistSession(currentSession) {\n    return setItemAsync(this.storage, this.storageKey, currentSession);\n  }\n  _removeSession() {\n    return __awaiter14(this, void 0, void 0, function* () {\n      if (this.persistSession) {\n        yield removeItemAsync(this.storage, this.storageKey);\n      } else {\n        this.inMemorySession = null;\n      }\n      if (this.refreshTokenTimer) {\n        clearTimeout(this.refreshTokenTimer);\n      }\n    });\n  }\n  _startAutoRefreshToken(value) {\n    if (this.refreshTokenTimer)\n      clearTimeout(this.refreshTokenTimer);\n    if (value <= 0 || !this.autoRefreshToken)\n      return;\n    this.refreshTokenTimer = setTimeout(() => __awaiter14(this, void 0, void 0, function* () {\n      this.networkRetries++;\n      const { data: { session }, error: sessionError } = yield this.getSession();\n      if (!sessionError && session) {\n        const { error } = yield this._callRefreshToken(session.refresh_token);\n        if (!error)\n          this.networkRetries = 0;\n        if (error instanceof AuthRetryableFetchError && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES)\n          this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100);\n      }\n    }), value);\n    if (typeof this.refreshTokenTimer.unref === \"function\")\n      this.refreshTokenTimer.unref();\n  }\n  _handleVisibilityChange() {\n    if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n      return false;\n    }\n    try {\n      window === null || window === void 0 ? void 0 : window.addEventListener(\"visibilitychange\", () => __awaiter14(this, void 0, void 0, function* () {\n        if (document.visibilityState === \"visible\") {\n          yield this.initializePromise;\n          yield this._recoverAndRefresh();\n        }\n      }));\n    } catch (error) {\n      console.error(\"_handleVisibilityChange\", error);\n    }\n  }\n  _getUrlForProvider(provider, options) {\n    const urlParams = [`provider=${encodeURIComponent(provider)}`];\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n    }\n    if (options === null || options === void 0 ? void 0 : options.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n    }\n    if (options === null || options === void 0 ? void 0 : options.queryParams) {\n      const query = new URLSearchParams(options.queryParams);\n      urlParams.push(query.toString());\n    }\n    return `${this.url}/authorize?${urlParams.join(\"&\")}`;\n  }\n  _unenroll(params) {\n    var _a;\n    return __awaiter14(this, void 0, void 0, function* () {\n      const { data: sessionData, error: sessionError } = yield this.getSession();\n      if (sessionError) {\n        return { data: null, error: sessionError };\n      }\n      return yield _request(this.fetch, \"DELETE\", `${this.url}/factors/${params.factorId}`, {\n        headers: this.headers,\n        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n      });\n    });\n  }\n  _enroll(params) {\n    var _a, _b;\n    return __awaiter14(this, void 0, void 0, function* () {\n      const { data: sessionData, error: sessionError } = yield this.getSession();\n      if (sessionError) {\n        return { data: null, error: sessionError };\n      }\n      const { data, error } = yield _request(this.fetch, \"POST\", `${this.url}/factors`, {\n        body: {\n          friendly_name: params.friendlyName,\n          factor_type: params.factorType,\n          issuer: params.issuer\n        },\n        headers: this.headers,\n        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n      });\n      if (error) {\n        return { data: null, error };\n      }\n      if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {\n        data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n      }\n      return { data, error: null };\n    });\n  }\n  _verify(params) {\n    var _a;\n    return __awaiter14(this, void 0, void 0, function* () {\n      const { data: sessionData, error: sessionError } = yield this.getSession();\n      if (sessionError) {\n        return { data: null, error: sessionError };\n      }\n      const { data, error } = yield _request(this.fetch, \"POST\", `${this.url}/factors/${params.factorId}/verify`, {\n        body: { code: params.code, challenge_id: params.challengeId },\n        headers: this.headers,\n        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n      });\n      if (error) {\n        return { data: null, error };\n      }\n      yield this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + data.expires_in }, data));\n      this._notifyAllSubscribers(\"MFA_CHALLENGE_VERIFIED\", data);\n      return { data, error };\n    });\n  }\n  _challenge(params) {\n    var _a;\n    return __awaiter14(this, void 0, void 0, function* () {\n      const { data: sessionData, error: sessionError } = yield this.getSession();\n      if (sessionError) {\n        return { data: null, error: sessionError };\n      }\n      return yield _request(this.fetch, \"POST\", `${this.url}/factors/${params.factorId}/challenge`, {\n        headers: this.headers,\n        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n      });\n    });\n  }\n  _challengeAndVerify(params) {\n    return __awaiter14(this, void 0, void 0, function* () {\n      const { data: challengeData, error: challengeError } = yield this._challenge({\n        factorId: params.factorId\n      });\n      if (challengeError) {\n        return { data: null, error: challengeError };\n      }\n      return yield this._verify({\n        factorId: params.factorId,\n        challengeId: challengeData.id,\n        code: params.code\n      });\n    });\n  }\n  _listFactors() {\n    return __awaiter14(this, void 0, void 0, function* () {\n      const { data: { user }, error: userError } = yield this.getUser();\n      if (userError) {\n        return { data: null, error: userError };\n      }\n      const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n      const totp = factors.filter((factor) => factor.factor_type === \"totp\" && factor.status === \"verified\");\n      return {\n        data: {\n          all: factors,\n          totp\n        },\n        error: null\n      };\n    });\n  }\n  _getAuthenticatorAssuranceLevel() {\n    var _a, _b;\n    return __awaiter14(this, void 0, void 0, function* () {\n      const { data: { session }, error: sessionError } = yield this.getSession();\n      if (sessionError) {\n        return { data: null, error: sessionError };\n      }\n      if (!session) {\n        return {\n          data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\n          error: null\n        };\n      }\n      const payload = this._decodeJWT(session.access_token);\n      let currentLevel = null;\n      if (payload.aal) {\n        currentLevel = payload.aal;\n      }\n      let nextLevel = currentLevel;\n      const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter((factor) => factor.status === \"verified\")) !== null && _b !== void 0 ? _b : [];\n      if (verifiedFactors.length > 0) {\n        nextLevel = \"aal2\";\n      }\n      const currentAuthenticationMethods = payload.amr || [];\n      return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };\n    });\n  }\n};\n\n// node_modules/.pnpm/@supabase+supabase-js@2.1.0/node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js\nvar SupabaseAuthClient = class extends GoTrueClient {\n  constructor(options) {\n    super(options);\n  }\n};\n\n// node_modules/.pnpm/@supabase+supabase-js@2.1.0/node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js\nvar __awaiter15 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar DEFAULT_GLOBAL_OPTIONS = {\n  headers: DEFAULT_HEADERS4\n};\nvar DEFAULT_DB_OPTIONS = {\n  schema: \"public\"\n};\nvar DEFAULT_AUTH_OPTIONS = {\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true\n};\nvar DEFAULT_REALTIME_OPTIONS = {};\nvar SupabaseClient = class {\n  constructor(supabaseUrl, supabaseKey, options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    this.supabaseUrl = supabaseUrl;\n    this.supabaseKey = supabaseKey;\n    if (!supabaseUrl)\n      throw new Error(\"supabaseUrl is required.\");\n    if (!supabaseKey)\n      throw new Error(\"supabaseKey is required.\");\n    const _supabaseUrl = stripTrailingSlash(supabaseUrl);\n    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, \"ws\");\n    this.authUrl = `${_supabaseUrl}/auth/v1`;\n    this.storageUrl = `${_supabaseUrl}/storage/v1`;\n    const isPlatform = _supabaseUrl.match(/(supabase\\.co)|(supabase\\.in)/);\n    if (isPlatform) {\n      const urlParts = _supabaseUrl.split(\".\");\n      this.functionsUrl = `${urlParts[0]}.functions.${urlParts[1]}.${urlParts[2]}`;\n    } else {\n      this.functionsUrl = `${_supabaseUrl}/functions/v1`;\n    }\n    const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split(\".\")[0]}-auth-token`;\n    const DEFAULTS = {\n      db: DEFAULT_DB_OPTIONS,\n      realtime: DEFAULT_REALTIME_OPTIONS,\n      auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), { storageKey: defaultStorageKey }),\n      global: DEFAULT_GLOBAL_OPTIONS\n    };\n    const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);\n    this.storageKey = (_b = (_a = settings.auth) === null || _a === void 0 ? void 0 : _a.storageKey) !== null && _b !== void 0 ? _b : \"\";\n    this.headers = (_d = (_c = settings.global) === null || _c === void 0 ? void 0 : _c.headers) !== null && _d !== void 0 ? _d : {};\n    this.auth = this._initSupabaseAuthClient((_e = settings.auth) !== null && _e !== void 0 ? _e : {}, this.headers, (_f = settings.global) === null || _f === void 0 ? void 0 : _f.fetch);\n    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), (_g = settings.global) === null || _g === void 0 ? void 0 : _g.fetch);\n    this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers }, settings.realtime));\n    this.rest = new PostgrestClient(`${_supabaseUrl}/rest/v1`, {\n      headers: this.headers,\n      schema: (_h = settings.db) === null || _h === void 0 ? void 0 : _h.schema,\n      fetch: this.fetch\n    });\n    this._listenForAuthEvents();\n  }\n  get functions() {\n    return new FunctionsClient(this.functionsUrl, {\n      headers: this.headers,\n      customFetch: this.fetch\n    });\n  }\n  get storage() {\n    return new StorageClient(this.storageUrl, this.headers, this.fetch);\n  }\n  from(relation) {\n    return this.rest.from(relation);\n  }\n  rpc(fn, args = {}, options) {\n    return this.rest.rpc(fn, args, options);\n  }\n  channel(name, opts = { config: {} }) {\n    return this.realtime.channel(name, opts);\n  }\n  getChannels() {\n    return this.realtime.getChannels();\n  }\n  removeChannel(channel) {\n    return this.realtime.removeChannel(channel);\n  }\n  removeAllChannels() {\n    return this.realtime.removeAllChannels();\n  }\n  _getAccessToken() {\n    var _a, _b;\n    return __awaiter15(this, void 0, void 0, function* () {\n      const { data } = yield this.auth.getSession();\n      return (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : null;\n    });\n  }\n  _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, storageKey }, headers, fetch2) {\n    const authHeaders = {\n      Authorization: `Bearer ${this.supabaseKey}`,\n      apikey: `${this.supabaseKey}`\n    };\n    return new SupabaseAuthClient({\n      url: this.authUrl,\n      headers: Object.assign(Object.assign({}, authHeaders), headers),\n      storageKey,\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      fetch: fetch2\n    });\n  }\n  _initRealtimeClient(options) {\n    return new RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), { params: Object.assign({ apikey: this.supabaseKey }, options === null || options === void 0 ? void 0 : options.params) }));\n  }\n  _listenForAuthEvents() {\n    let data = this.auth.onAuthStateChange((event, session) => {\n      this._handleTokenChanged(event, session === null || session === void 0 ? void 0 : session.access_token, \"CLIENT\");\n    });\n    return data;\n  }\n  _handleTokenChanged(event, token, source) {\n    if ((event === \"TOKEN_REFRESHED\" || event === \"SIGNED_IN\") && this.changedAccessToken !== token) {\n      this.realtime.setAuth(token !== null && token !== void 0 ? token : null);\n      this.changedAccessToken = token;\n    } else if (event === \"SIGNED_OUT\" || event === \"USER_DELETED\") {\n      this.realtime.setAuth(this.supabaseKey);\n      if (source == \"STORAGE\")\n        this.auth.signOut();\n    }\n  }\n};\n\n// node_modules/.pnpm/@supabase+supabase-js@2.1.0/node_modules/@supabase/supabase-js/dist/module/index.js\nvar createClient = (supabaseUrl, supabaseKey, options) => {\n  return new SupabaseClient(supabaseUrl, supabaseKey, options);\n};\nexport {\n  AuthApiError,\n  AuthError,\n  AuthImplicitGrantRedirectError,\n  AuthInvalidCredentialsError,\n  AuthRetryableFetchError,\n  AuthSessionMissingError,\n  AuthUnknownError,\n  CustomAuthError,\n  FunctionsError,\n  FunctionsFetchError,\n  FunctionsHttpError,\n  FunctionsRelayError,\n  GoTrueAdminApi,\n  GoTrueClient,\n  REALTIME_LISTEN_TYPES,\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT,\n  REALTIME_PRESENCE_LISTEN_EVENTS,\n  REALTIME_SUBSCRIBE_STATES,\n  RealtimeChannel,\n  RealtimeClient,\n  RealtimePresence,\n  SupabaseClient,\n  createClient,\n  isAuthError\n};\n//# sourceMappingURL=@supabase_supabase-js.js.map\n",
      "start": 1681505639033,
      "end": 1681505639047
    },
    {
      "name": "vite:import-analysis",
      "result": "import {\n  require_browser_ponyfill\n} from \"/node_modules/.vite/deps/chunk-ZVVIQIK2.js?v=5c95b2a1\";\nimport {\n  __commonJS,\n  __toESM\n} from \"/node_modules/.vite/deps/chunk-TWLJ45QX.js?v=5c95b2a1\";\n\n// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/global.js\nvar require_global = __commonJS({\n  \"node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/global.js\"(exports, module) {\n    var naiveFallback = function() {\n      if (typeof self === \"object\" && self)\n        return self;\n      if (typeof window === \"object\" && window)\n        return window;\n      throw new Error(\"Unable to resolve global `this`\");\n    };\n    module.exports = function() {\n      if (this)\n        return this;\n      if (typeof globalThis === \"object\" && globalThis)\n        return globalThis;\n      try {\n        Object.defineProperty(Object.prototype, \"__global__\", {\n          get: function() {\n            return this;\n          },\n          configurable: true\n        });\n      } catch (error) {\n        return naiveFallback();\n      }\n      try {\n        if (!__global__)\n          return naiveFallback();\n        return __global__;\n      } finally {\n        delete Object.prototype.__global__;\n      }\n    }();\n  }\n});\n\n// node_modules/.pnpm/websocket@1.0.34/node_modules/websocket/package.json\nvar require_package = __commonJS({\n  \"node_modules/.pnpm/websocket@1.0.34/node_modules/websocket/package.json\"(exports, module) {\n    module.exports = {\n      name: \"websocket\",\n      description: \"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.\",\n      keywords: [\n        \"websocket\",\n        \"websockets\",\n        \"socket\",\n        \"networking\",\n        \"comet\",\n        \"push\",\n        \"RFC-6455\",\n        \"realtime\",\n        \"server\",\n        \"client\"\n      ],\n      author: \"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)\",\n      contributors: [\n        \"I\\xF1aki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)\"\n      ],\n      version: \"1.0.34\",\n      repository: {\n        type: \"git\",\n        url: \"https://github.com/theturtle32/WebSocket-Node.git\"\n      },\n      homepage: \"https://github.com/theturtle32/WebSocket-Node\",\n      engines: {\n        node: \">=4.0.0\"\n      },\n      dependencies: {\n        bufferutil: \"^4.0.1\",\n        debug: \"^2.2.0\",\n        \"es5-ext\": \"^0.10.50\",\n        \"typedarray-to-buffer\": \"^3.1.5\",\n        \"utf-8-validate\": \"^5.0.2\",\n        yaeti: \"^0.0.6\"\n      },\n      devDependencies: {\n        \"buffer-equal\": \"^1.0.0\",\n        gulp: \"^4.0.2\",\n        \"gulp-jshint\": \"^2.0.4\",\n        \"jshint-stylish\": \"^2.2.1\",\n        jshint: \"^2.0.0\",\n        tape: \"^4.9.1\"\n      },\n      config: {\n        verbose: false\n      },\n      scripts: {\n        test: \"tape test/unit/*.js\",\n        gulp: \"gulp\"\n      },\n      main: \"index\",\n      directories: {\n        lib: \"./lib\"\n      },\n      browser: \"lib/browser.js\",\n      license: \"Apache-2.0\"\n    };\n  }\n});\n\n// node_modules/.pnpm/websocket@1.0.34/node_modules/websocket/lib/version.js\nvar require_version = __commonJS({\n  \"node_modules/.pnpm/websocket@1.0.34/node_modules/websocket/lib/version.js\"(exports, module) {\n    module.exports = require_package().version;\n  }\n});\n\n// node_modules/.pnpm/websocket@1.0.34/node_modules/websocket/lib/browser.js\nvar require_browser = __commonJS({\n  \"node_modules/.pnpm/websocket@1.0.34/node_modules/websocket/lib/browser.js\"(exports, module) {\n    var _globalThis;\n    if (typeof globalThis === \"object\") {\n      _globalThis = globalThis;\n    } else {\n      try {\n        _globalThis = require_global();\n      } catch (error) {\n      } finally {\n        if (!_globalThis && typeof window !== \"undefined\") {\n          _globalThis = window;\n        }\n        if (!_globalThis) {\n          throw new Error(\"Could not determine global this\");\n        }\n      }\n    }\n    var NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\n    var websocket_version = require_version();\n    function W3CWebSocket(uri, protocols) {\n      var native_instance;\n      if (protocols) {\n        native_instance = new NativeWebSocket(uri, protocols);\n      } else {\n        native_instance = new NativeWebSocket(uri);\n      }\n      return native_instance;\n    }\n    if (NativeWebSocket) {\n      [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"].forEach(function(prop) {\n        Object.defineProperty(W3CWebSocket, prop, {\n          get: function() {\n            return NativeWebSocket[prop];\n          }\n        });\n      });\n    }\n    module.exports = {\n      \"w3cwebsocket\": NativeWebSocket ? W3CWebSocket : null,\n      \"version\": websocket_version\n    };\n  }\n});\n\n// node_modules/.pnpm/@supabase+functions-js@2.0.0/node_modules/@supabase/functions-js/dist/module/helper.js\nvar __awaiter = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar resolveFetch = (customFetch) => {\n  let _fetch;\n  if (customFetch) {\n    _fetch = customFetch;\n  } else if (typeof fetch === \"undefined\") {\n    _fetch = (...args) => __awaiter(void 0, void 0, void 0, function* () {\n      return yield (yield import(\"/node_modules/.vite/deps/browser-ponyfill-T7ISBDOE.js?v=5c95b2a1\")).fetch(...args);\n    });\n  } else {\n    _fetch = fetch;\n  }\n  return (...args) => _fetch(...args);\n};\n\n// node_modules/.pnpm/@supabase+functions-js@2.0.0/node_modules/@supabase/functions-js/dist/module/types.js\nvar FunctionsError = class extends Error {\n  constructor(message, name = \"FunctionsError\", context) {\n    super(message);\n    super.name = name;\n    this.context = context;\n  }\n};\nvar FunctionsFetchError = class extends FunctionsError {\n  constructor(context) {\n    super(\"Failed to send a request to the Edge Function\", \"FunctionsFetchError\", context);\n  }\n};\nvar FunctionsRelayError = class extends FunctionsError {\n  constructor(context) {\n    super(\"Relay Error invoking the Edge Function\", \"FunctionsRelayError\", context);\n  }\n};\nvar FunctionsHttpError = class extends FunctionsError {\n  constructor(context) {\n    super(\"Edge Function returned a non-2xx status code\", \"FunctionsHttpError\", context);\n  }\n};\n\n// node_modules/.pnpm/@supabase+functions-js@2.0.0/node_modules/@supabase/functions-js/dist/module/FunctionsClient.js\nvar __awaiter2 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar FunctionsClient = class {\n  constructor(url, { headers = {}, customFetch } = {}) {\n    this.url = url;\n    this.headers = headers;\n    this.fetch = resolveFetch(customFetch);\n  }\n  setAuth(token) {\n    this.headers.Authorization = `Bearer ${token}`;\n  }\n  invoke(functionName, invokeOptions = {}) {\n    var _a;\n    return __awaiter2(this, void 0, void 0, function* () {\n      try {\n        const { headers, body: functionArgs } = invokeOptions;\n        let _headers = {};\n        let body;\n        if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, \"Content-Type\") || !headers)) {\n          if (typeof Blob !== \"undefined\" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {\n            _headers[\"Content-Type\"] = \"application/octet-stream\";\n            body = functionArgs;\n          } else if (typeof functionArgs === \"string\") {\n            _headers[\"Content-Type\"] = \"text/plain\";\n            body = functionArgs;\n          } else if (typeof FormData !== \"undefined\" && functionArgs instanceof FormData) {\n            body = functionArgs;\n          } else {\n            _headers[\"Content-Type\"] = \"application/json\";\n            body = JSON.stringify(functionArgs);\n          }\n        }\n        const response = yield this.fetch(`${this.url}/${functionName}`, {\n          method: \"POST\",\n          headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),\n          body\n        }).catch((fetchError) => {\n          throw new FunctionsFetchError(fetchError);\n        });\n        const isRelayError = response.headers.get(\"x-relay-error\");\n        if (isRelayError && isRelayError === \"true\") {\n          throw new FunctionsRelayError(response);\n        }\n        if (!response.ok) {\n          throw new FunctionsHttpError(response);\n        }\n        let responseType = ((_a = response.headers.get(\"Content-Type\")) !== null && _a !== void 0 ? _a : \"text/plain\").split(\";\")[0].trim();\n        let data;\n        if (responseType === \"application/json\") {\n          data = yield response.json();\n        } else if (responseType === \"application/octet-stream\") {\n          data = yield response.blob();\n        } else if (responseType === \"multipart/form-data\") {\n          data = yield response.formData();\n        } else {\n          data = yield response.text();\n        }\n        return { data, error: null };\n      } catch (error) {\n        return { data: null, error };\n      }\n    });\n  }\n};\n\n// node_modules/.pnpm/@supabase+postgrest-js@1.1.0/node_modules/@supabase/postgrest-js/dist/module/PostgrestBuilder.js\nvar import_cross_fetch = __toESM(require_browser_ponyfill());\nvar __awaiter3 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar PostgrestBuilder = class {\n  constructor(builder) {\n    this.shouldThrowOnError = false;\n    this.method = builder.method;\n    this.url = builder.url;\n    this.headers = builder.headers;\n    this.schema = builder.schema;\n    this.body = builder.body;\n    this.shouldThrowOnError = builder.shouldThrowOnError;\n    this.signal = builder.signal;\n    this.allowEmpty = builder.allowEmpty;\n    if (builder.fetch) {\n      this.fetch = builder.fetch;\n    } else if (typeof fetch === \"undefined\") {\n      this.fetch = import_cross_fetch.default;\n    } else {\n      this.fetch = fetch;\n    }\n  }\n  throwOnError() {\n    this.shouldThrowOnError = true;\n    return this;\n  }\n  then(onfulfilled, onrejected) {\n    if (this.schema === void 0) {\n    } else if ([\"GET\", \"HEAD\"].includes(this.method)) {\n      this.headers[\"Accept-Profile\"] = this.schema;\n    } else {\n      this.headers[\"Content-Profile\"] = this.schema;\n    }\n    if (this.method !== \"GET\" && this.method !== \"HEAD\") {\n      this.headers[\"Content-Type\"] = \"application/json\";\n    }\n    const _fetch = this.fetch;\n    let res = _fetch(this.url.toString(), {\n      method: this.method,\n      headers: this.headers,\n      body: JSON.stringify(this.body),\n      signal: this.signal\n    }).then((res2) => __awaiter3(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n      let error = null;\n      let data = null;\n      let count = null;\n      let status = res2.status;\n      let statusText = res2.statusText;\n      if (res2.ok) {\n        if (this.method !== \"HEAD\") {\n          const body = yield res2.text();\n          if (body === \"\") {\n          } else if (this.headers[\"Accept\"] === \"text/csv\") {\n            data = body;\n          } else if (this.headers[\"Accept\"] && this.headers[\"Accept\"].includes(\"application/vnd.pgrst.plan+text\")) {\n            data = body;\n          } else {\n            data = JSON.parse(body);\n          }\n        }\n        const countHeader = (_a = this.headers[\"Prefer\"]) === null || _a === void 0 ? void 0 : _a.match(/count=(exact|planned|estimated)/);\n        const contentRange = (_b = res2.headers.get(\"content-range\")) === null || _b === void 0 ? void 0 : _b.split(\"/\");\n        if (countHeader && contentRange && contentRange.length > 1) {\n          count = parseInt(contentRange[1]);\n        }\n      } else {\n        const body = yield res2.text();\n        try {\n          error = JSON.parse(body);\n        } catch (_d) {\n          error = {\n            message: body\n          };\n        }\n        if (error && this.allowEmpty && ((_c = error === null || error === void 0 ? void 0 : error.details) === null || _c === void 0 ? void 0 : _c.includes(\"Results contain 0 rows\"))) {\n          error = null;\n          status = 200;\n          statusText = \"OK\";\n        }\n        if (error && this.shouldThrowOnError) {\n          throw error;\n        }\n      }\n      const postgrestResponse = {\n        error,\n        data,\n        count,\n        status,\n        statusText\n      };\n      return postgrestResponse;\n    }));\n    if (!this.shouldThrowOnError) {\n      res = res.catch((fetchError) => ({\n        error: {\n          message: `FetchError: ${fetchError.message}`,\n          details: \"\",\n          hint: \"\",\n          code: fetchError.code || \"\"\n        },\n        data: null,\n        count: null,\n        status: 0,\n        statusText: \"\"\n      }));\n    }\n    return res.then(onfulfilled, onrejected);\n  }\n};\n\n// node_modules/.pnpm/@supabase+postgrest-js@1.1.0/node_modules/@supabase/postgrest-js/dist/module/PostgrestTransformBuilder.js\nvar PostgrestTransformBuilder = class extends PostgrestBuilder {\n  select(columns) {\n    let quoted = false;\n    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c) => {\n      if (/\\s/.test(c) && !quoted) {\n        return \"\";\n      }\n      if (c === '\"') {\n        quoted = !quoted;\n      }\n      return c;\n    }).join(\"\");\n    this.url.searchParams.set(\"select\", cleanedColumns);\n    if (this.headers[\"Prefer\"]) {\n      this.headers[\"Prefer\"] += \",\";\n    }\n    this.headers[\"Prefer\"] += \"return=representation\";\n    return this;\n  }\n  order(column, { ascending = true, nullsFirst, foreignTable } = {}) {\n    const key = foreignTable ? `${foreignTable}.order` : \"order\";\n    const existingOrder = this.url.searchParams.get(key);\n    this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : \"\"}${column}.${ascending ? \"asc\" : \"desc\"}${nullsFirst === void 0 ? \"\" : nullsFirst ? \".nullsfirst\" : \".nullslast\"}`);\n    return this;\n  }\n  limit(count, { foreignTable } = {}) {\n    const key = typeof foreignTable === \"undefined\" ? \"limit\" : `${foreignTable}.limit`;\n    this.url.searchParams.set(key, `${count}`);\n    return this;\n  }\n  range(from, to, { foreignTable } = {}) {\n    const keyOffset = typeof foreignTable === \"undefined\" ? \"offset\" : `${foreignTable}.offset`;\n    const keyLimit = typeof foreignTable === \"undefined\" ? \"limit\" : `${foreignTable}.limit`;\n    this.url.searchParams.set(keyOffset, `${from}`);\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`);\n    return this;\n  }\n  abortSignal(signal) {\n    this.signal = signal;\n    return this;\n  }\n  single() {\n    this.headers[\"Accept\"] = \"application/vnd.pgrst.object+json\";\n    return this;\n  }\n  maybeSingle() {\n    this.headers[\"Accept\"] = \"application/vnd.pgrst.object+json\";\n    this.allowEmpty = true;\n    return this;\n  }\n  csv() {\n    this.headers[\"Accept\"] = \"text/csv\";\n    return this;\n  }\n  geojson() {\n    this.headers[\"Accept\"] = \"application/geo+json\";\n    return this;\n  }\n  explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = \"text\" } = {}) {\n    const options = [\n      analyze ? \"analyze\" : null,\n      verbose ? \"verbose\" : null,\n      settings ? \"settings\" : null,\n      buffers ? \"buffers\" : null,\n      wal ? \"wal\" : null\n    ].filter(Boolean).join(\"|\");\n    const forMediatype = this.headers[\"Accept\"];\n    this.headers[\"Accept\"] = `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`;\n    if (format === \"json\")\n      return this;\n    else\n      return this;\n  }\n  rollback() {\n    var _a;\n    if (((_a = this.headers[\"Prefer\"]) !== null && _a !== void 0 ? _a : \"\").trim().length > 0) {\n      this.headers[\"Prefer\"] += \",tx=rollback\";\n    } else {\n      this.headers[\"Prefer\"] = \"tx=rollback\";\n    }\n    return this;\n  }\n  returns() {\n    return this;\n  }\n};\n\n// node_modules/.pnpm/@supabase+postgrest-js@1.1.0/node_modules/@supabase/postgrest-js/dist/module/PostgrestFilterBuilder.js\nvar PostgrestFilterBuilder = class extends PostgrestTransformBuilder {\n  eq(column, value) {\n    this.url.searchParams.append(column, `eq.${value}`);\n    return this;\n  }\n  neq(column, value) {\n    this.url.searchParams.append(column, `neq.${value}`);\n    return this;\n  }\n  gt(column, value) {\n    this.url.searchParams.append(column, `gt.${value}`);\n    return this;\n  }\n  gte(column, value) {\n    this.url.searchParams.append(column, `gte.${value}`);\n    return this;\n  }\n  lt(column, value) {\n    this.url.searchParams.append(column, `lt.${value}`);\n    return this;\n  }\n  lte(column, value) {\n    this.url.searchParams.append(column, `lte.${value}`);\n    return this;\n  }\n  like(column, pattern) {\n    this.url.searchParams.append(column, `like.${pattern}`);\n    return this;\n  }\n  ilike(column, pattern) {\n    this.url.searchParams.append(column, `ilike.${pattern}`);\n    return this;\n  }\n  is(column, value) {\n    this.url.searchParams.append(column, `is.${value}`);\n    return this;\n  }\n  in(column, values) {\n    const cleanedValues = values.map((s) => {\n      if (typeof s === \"string\" && new RegExp(\"[,()]\").test(s))\n        return `\"${s}\"`;\n      else\n        return `${s}`;\n    }).join(\",\");\n    this.url.searchParams.append(column, `in.(${cleanedValues})`);\n    return this;\n  }\n  contains(column, value) {\n    if (typeof value === \"string\") {\n      this.url.searchParams.append(column, `cs.${value}`);\n    } else if (Array.isArray(value)) {\n      this.url.searchParams.append(column, `cs.{${value.join(\",\")}}`);\n    } else {\n      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);\n    }\n    return this;\n  }\n  containedBy(column, value) {\n    if (typeof value === \"string\") {\n      this.url.searchParams.append(column, `cd.${value}`);\n    } else if (Array.isArray(value)) {\n      this.url.searchParams.append(column, `cd.{${value.join(\",\")}}`);\n    } else {\n      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);\n    }\n    return this;\n  }\n  rangeGt(column, range) {\n    this.url.searchParams.append(column, `sr.${range}`);\n    return this;\n  }\n  rangeGte(column, range) {\n    this.url.searchParams.append(column, `nxl.${range}`);\n    return this;\n  }\n  rangeLt(column, range) {\n    this.url.searchParams.append(column, `sl.${range}`);\n    return this;\n  }\n  rangeLte(column, range) {\n    this.url.searchParams.append(column, `nxr.${range}`);\n    return this;\n  }\n  rangeAdjacent(column, range) {\n    this.url.searchParams.append(column, `adj.${range}`);\n    return this;\n  }\n  overlaps(column, value) {\n    if (typeof value === \"string\") {\n      this.url.searchParams.append(column, `ov.${value}`);\n    } else {\n      this.url.searchParams.append(column, `ov.{${value.join(\",\")}}`);\n    }\n    return this;\n  }\n  textSearch(column, query, { config, type } = {}) {\n    let typePart = \"\";\n    if (type === \"plain\") {\n      typePart = \"pl\";\n    } else if (type === \"phrase\") {\n      typePart = \"ph\";\n    } else if (type === \"websearch\") {\n      typePart = \"w\";\n    }\n    const configPart = config === void 0 ? \"\" : `(${config})`;\n    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);\n    return this;\n  }\n  match(query) {\n    Object.entries(query).forEach(([column, value]) => {\n      this.url.searchParams.append(column, `eq.${value}`);\n    });\n    return this;\n  }\n  not(column, operator, value) {\n    this.url.searchParams.append(column, `not.${operator}.${value}`);\n    return this;\n  }\n  or(filters, { foreignTable } = {}) {\n    const key = foreignTable ? `${foreignTable}.or` : \"or\";\n    this.url.searchParams.append(key, `(${filters})`);\n    return this;\n  }\n  filter(column, operator, value) {\n    this.url.searchParams.append(column, `${operator}.${value}`);\n    return this;\n  }\n};\n\n// node_modules/.pnpm/@supabase+postgrest-js@1.1.0/node_modules/@supabase/postgrest-js/dist/module/PostgrestQueryBuilder.js\nvar PostgrestQueryBuilder = class {\n  constructor(url, { headers = {}, schema, fetch: fetch2 }) {\n    this.url = url;\n    this.headers = headers;\n    this.schema = schema;\n    this.fetch = fetch2;\n  }\n  select(columns, { head = false, count } = {}) {\n    const method = head ? \"HEAD\" : \"GET\";\n    let quoted = false;\n    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c) => {\n      if (/\\s/.test(c) && !quoted) {\n        return \"\";\n      }\n      if (c === '\"') {\n        quoted = !quoted;\n      }\n      return c;\n    }).join(\"\");\n    this.url.searchParams.set(\"select\", cleanedColumns);\n    if (count) {\n      this.headers[\"Prefer\"] = `count=${count}`;\n    }\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  insert(values, { count } = {}) {\n    const method = \"POST\";\n    const prefersHeaders = [];\n    const body = values;\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n    if (this.headers[\"Prefer\"]) {\n      prefersHeaders.unshift(this.headers[\"Prefer\"]);\n    }\n    this.headers[\"Prefer\"] = prefersHeaders.join(\",\");\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`);\n        this.url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n      }\n    }\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  upsert(values, { onConflict, ignoreDuplicates = false, count } = {}) {\n    const method = \"POST\";\n    const prefersHeaders = [`resolution=${ignoreDuplicates ? \"ignore\" : \"merge\"}-duplicates`];\n    if (onConflict !== void 0)\n      this.url.searchParams.set(\"on_conflict\", onConflict);\n    const body = values;\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n    if (this.headers[\"Prefer\"]) {\n      prefersHeaders.unshift(this.headers[\"Prefer\"]);\n    }\n    this.headers[\"Prefer\"] = prefersHeaders.join(\",\");\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  update(values, { count } = {}) {\n    const method = \"PATCH\";\n    const prefersHeaders = [];\n    const body = values;\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n    if (this.headers[\"Prefer\"]) {\n      prefersHeaders.unshift(this.headers[\"Prefer\"]);\n    }\n    this.headers[\"Prefer\"] = prefersHeaders.join(\",\");\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  delete({ count } = {}) {\n    const method = \"DELETE\";\n    const prefersHeaders = [];\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n    if (this.headers[\"Prefer\"]) {\n      prefersHeaders.unshift(this.headers[\"Prefer\"]);\n    }\n    this.headers[\"Prefer\"] = prefersHeaders.join(\",\");\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n};\n\n// node_modules/.pnpm/@supabase+postgrest-js@1.1.0/node_modules/@supabase/postgrest-js/dist/module/version.js\nvar version = \"1.1.0\";\n\n// node_modules/.pnpm/@supabase+postgrest-js@1.1.0/node_modules/@supabase/postgrest-js/dist/module/constants.js\nvar DEFAULT_HEADERS = { \"X-Client-Info\": `postgrest-js/${version}` };\n\n// node_modules/.pnpm/@supabase+postgrest-js@1.1.0/node_modules/@supabase/postgrest-js/dist/module/PostgrestClient.js\nvar PostgrestClient = class {\n  constructor(url, { headers = {}, schema, fetch: fetch2 } = {}) {\n    this.url = url;\n    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers);\n    this.schema = schema;\n    this.fetch = fetch2;\n  }\n  from(relation) {\n    const url = new URL(`${this.url}/${relation}`);\n    return new PostgrestQueryBuilder(url, {\n      headers: Object.assign({}, this.headers),\n      schema: this.schema,\n      fetch: this.fetch\n    });\n  }\n  rpc(fn, args = {}, { head = false, count } = {}) {\n    let method;\n    const url = new URL(`${this.url}/rpc/${fn}`);\n    let body;\n    if (head) {\n      method = \"HEAD\";\n      Object.entries(args).forEach(([name, value]) => {\n        url.searchParams.append(name, `${value}`);\n      });\n    } else {\n      method = \"POST\";\n      body = args;\n    }\n    const headers = Object.assign({}, this.headers);\n    if (count) {\n      headers[\"Prefer\"] = `count=${count}`;\n    }\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n};\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\nvar import_websocket = __toESM(require_browser());\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/lib/version.js\nvar version2 = \"2.1.0\";\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/lib/constants.js\nvar DEFAULT_HEADERS2 = { \"X-Client-Info\": `realtime-js/${version2}` };\nvar VSN = \"1.0.0\";\nvar DEFAULT_TIMEOUT = 1e4;\nvar WS_CLOSE_NORMAL = 1e3;\nvar SOCKET_STATES;\n(function(SOCKET_STATES2) {\n  SOCKET_STATES2[SOCKET_STATES2[\"connecting\"] = 0] = \"connecting\";\n  SOCKET_STATES2[SOCKET_STATES2[\"open\"] = 1] = \"open\";\n  SOCKET_STATES2[SOCKET_STATES2[\"closing\"] = 2] = \"closing\";\n  SOCKET_STATES2[SOCKET_STATES2[\"closed\"] = 3] = \"closed\";\n})(SOCKET_STATES || (SOCKET_STATES = {}));\nvar CHANNEL_STATES;\n(function(CHANNEL_STATES2) {\n  CHANNEL_STATES2[\"closed\"] = \"closed\";\n  CHANNEL_STATES2[\"errored\"] = \"errored\";\n  CHANNEL_STATES2[\"joined\"] = \"joined\";\n  CHANNEL_STATES2[\"joining\"] = \"joining\";\n  CHANNEL_STATES2[\"leaving\"] = \"leaving\";\n})(CHANNEL_STATES || (CHANNEL_STATES = {}));\nvar CHANNEL_EVENTS;\n(function(CHANNEL_EVENTS2) {\n  CHANNEL_EVENTS2[\"close\"] = \"phx_close\";\n  CHANNEL_EVENTS2[\"error\"] = \"phx_error\";\n  CHANNEL_EVENTS2[\"join\"] = \"phx_join\";\n  CHANNEL_EVENTS2[\"reply\"] = \"phx_reply\";\n  CHANNEL_EVENTS2[\"leave\"] = \"phx_leave\";\n  CHANNEL_EVENTS2[\"access_token\"] = \"access_token\";\n})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));\nvar TRANSPORTS;\n(function(TRANSPORTS2) {\n  TRANSPORTS2[\"websocket\"] = \"websocket\";\n})(TRANSPORTS || (TRANSPORTS = {}));\nvar CONNECTION_STATE;\n(function(CONNECTION_STATE2) {\n  CONNECTION_STATE2[\"Connecting\"] = \"connecting\";\n  CONNECTION_STATE2[\"Open\"] = \"open\";\n  CONNECTION_STATE2[\"Closing\"] = \"closing\";\n  CONNECTION_STATE2[\"Closed\"] = \"closed\";\n})(CONNECTION_STATE || (CONNECTION_STATE = {}));\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/lib/timer.js\nvar Timer = class {\n  constructor(callback, timerCalc) {\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = void 0;\n    this.tries = 0;\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n  }\n  reset() {\n    this.tries = 0;\n    clearTimeout(this.timer);\n  }\n  scheduleTimeout() {\n    clearTimeout(this.timer);\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1;\n      this.callback();\n    }, this.timerCalc(this.tries + 1));\n  }\n};\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/lib/serializer.js\nvar Serializer = class {\n  constructor() {\n    this.HEADER_LENGTH = 1;\n  }\n  decode(rawPayload, callback) {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this._binaryDecode(rawPayload));\n    }\n    if (typeof rawPayload === \"string\") {\n      return callback(JSON.parse(rawPayload));\n    }\n    return callback({});\n  }\n  _binaryDecode(buffer) {\n    const view = new DataView(buffer);\n    const decoder = new TextDecoder();\n    return this._decodeBroadcast(buffer, view, decoder);\n  }\n  _decodeBroadcast(buffer, view, decoder) {\n    const topicSize = view.getUint8(1);\n    const eventSize = view.getUint8(2);\n    let offset = this.HEADER_LENGTH + 2;\n    const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n    offset = offset + topicSize;\n    const event = decoder.decode(buffer.slice(offset, offset + eventSize));\n    offset = offset + eventSize;\n    const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));\n    return { ref: null, topic, event, payload: data };\n  }\n};\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/lib/push.js\nvar Push = class {\n  constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload;\n    this.timeout = timeout;\n    this.sent = false;\n    this.timeoutTimer = void 0;\n    this.ref = \"\";\n    this.receivedResp = null;\n    this.recHooks = [];\n    this.refEvent = null;\n    this.rateLimited = false;\n  }\n  resend(timeout) {\n    this.timeout = timeout;\n    this._cancelRefEvent();\n    this.ref = \"\";\n    this.refEvent = null;\n    this.receivedResp = null;\n    this.sent = false;\n    this.send();\n  }\n  send() {\n    if (this._hasReceived(\"timeout\")) {\n      return;\n    }\n    this.startTimeout();\n    this.sent = true;\n    const status = this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload,\n      ref: this.ref,\n      join_ref: this.channel._joinRef()\n    });\n    if (status === \"rate limited\") {\n      this.rateLimited = true;\n    }\n  }\n  updatePayload(payload) {\n    this.payload = Object.assign(Object.assign({}, this.payload), payload);\n  }\n  receive(status, callback) {\n    var _a;\n    if (this._hasReceived(status)) {\n      callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n    }\n    this.recHooks.push({ status, callback });\n    return this;\n  }\n  startTimeout() {\n    if (this.timeoutTimer) {\n      return;\n    }\n    this.ref = this.channel.socket._makeRef();\n    this.refEvent = this.channel._replyEventName(this.ref);\n    const callback = (payload) => {\n      this._cancelRefEvent();\n      this._cancelTimeout();\n      this.receivedResp = payload;\n      this._matchReceive(payload);\n    };\n    this.channel._on(this.refEvent, {}, callback);\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger(\"timeout\", {});\n    }, this.timeout);\n  }\n  trigger(status, response) {\n    if (this.refEvent)\n      this.channel._trigger(this.refEvent, { status, response });\n  }\n  destroy() {\n    this._cancelRefEvent();\n    this._cancelTimeout();\n  }\n  _cancelRefEvent() {\n    if (!this.refEvent) {\n      return;\n    }\n    this.channel._off(this.refEvent, {});\n  }\n  _cancelTimeout() {\n    clearTimeout(this.timeoutTimer);\n    this.timeoutTimer = void 0;\n  }\n  _matchReceive({ status, response }) {\n    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));\n  }\n  _hasReceived(status) {\n    return this.receivedResp && this.receivedResp.status === status;\n  }\n};\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\nvar REALTIME_PRESENCE_LISTEN_EVENTS;\n(function(REALTIME_PRESENCE_LISTEN_EVENTS2) {\n  REALTIME_PRESENCE_LISTEN_EVENTS2[\"SYNC\"] = \"sync\";\n  REALTIME_PRESENCE_LISTEN_EVENTS2[\"JOIN\"] = \"join\";\n  REALTIME_PRESENCE_LISTEN_EVENTS2[\"LEAVE\"] = \"leave\";\n})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));\nvar RealtimePresence = class {\n  constructor(channel, opts) {\n    this.channel = channel;\n    this.state = {};\n    this.pendingDiffs = [];\n    this.joinRef = null;\n    this.caller = {\n      onJoin: () => {\n      },\n      onLeave: () => {\n      },\n      onSync: () => {\n      }\n    };\n    const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {\n      state: \"presence_state\",\n      diff: \"presence_diff\"\n    };\n    this.channel._on(events.state, {}, (newState) => {\n      const { onJoin, onLeave, onSync } = this.caller;\n      this.joinRef = this.channel._joinRef();\n      this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);\n      this.pendingDiffs.forEach((diff) => {\n        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n      });\n      this.pendingDiffs = [];\n      onSync();\n    });\n    this.channel._on(events.diff, {}, (diff) => {\n      const { onJoin, onLeave, onSync } = this.caller;\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff);\n      } else {\n        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n        onSync();\n      }\n    });\n    this.onJoin((key, currentPresences, newPresences) => {\n      this.channel._trigger(\"presence\", {\n        event: \"join\",\n        key,\n        currentPresences,\n        newPresences\n      });\n    });\n    this.onLeave((key, currentPresences, leftPresences) => {\n      this.channel._trigger(\"presence\", {\n        event: \"leave\",\n        key,\n        currentPresences,\n        leftPresences\n      });\n    });\n    this.onSync(() => {\n      this.channel._trigger(\"presence\", { event: \"sync\" });\n    });\n  }\n  static syncState(currentState, newState, onJoin, onLeave) {\n    const state = this.cloneDeep(currentState);\n    const transformedState = this.transformState(newState);\n    const joins = {};\n    const leaves = {};\n    this.map(state, (key, presences) => {\n      if (!transformedState[key]) {\n        leaves[key] = presences;\n      }\n    });\n    this.map(transformedState, (key, newPresences) => {\n      const currentPresences = state[key];\n      if (currentPresences) {\n        const newPresenceRefs = newPresences.map((m) => m.presence_ref);\n        const curPresenceRefs = currentPresences.map((m) => m.presence_ref);\n        const joinedPresences = newPresences.filter((m) => curPresenceRefs.indexOf(m.presence_ref) < 0);\n        const leftPresences = currentPresences.filter((m) => newPresenceRefs.indexOf(m.presence_ref) < 0);\n        if (joinedPresences.length > 0) {\n          joins[key] = joinedPresences;\n        }\n        if (leftPresences.length > 0) {\n          leaves[key] = leftPresences;\n        }\n      } else {\n        joins[key] = newPresences;\n      }\n    });\n    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);\n  }\n  static syncDiff(state, diff, onJoin, onLeave) {\n    const { joins, leaves } = {\n      joins: this.transformState(diff.joins),\n      leaves: this.transformState(diff.leaves)\n    };\n    if (!onJoin) {\n      onJoin = () => {\n      };\n    }\n    if (!onLeave) {\n      onLeave = () => {\n      };\n    }\n    this.map(joins, (key, newPresences) => {\n      var _a;\n      const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];\n      state[key] = this.cloneDeep(newPresences);\n      if (currentPresences.length > 0) {\n        const joinedPresenceRefs = state[key].map((m) => m.presence_ref);\n        const curPresences = currentPresences.filter((m) => joinedPresenceRefs.indexOf(m.presence_ref) < 0);\n        state[key].unshift(...curPresences);\n      }\n      onJoin(key, currentPresences, newPresences);\n    });\n    this.map(leaves, (key, leftPresences) => {\n      let currentPresences = state[key];\n      if (!currentPresences)\n        return;\n      const presenceRefsToRemove = leftPresences.map((m) => m.presence_ref);\n      currentPresences = currentPresences.filter((m) => presenceRefsToRemove.indexOf(m.presence_ref) < 0);\n      state[key] = currentPresences;\n      onLeave(key, currentPresences, leftPresences);\n      if (currentPresences.length === 0)\n        delete state[key];\n    });\n    return state;\n  }\n  static map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));\n  }\n  static transformState(state) {\n    state = this.cloneDeep(state);\n    return Object.getOwnPropertyNames(state).reduce((newState, key) => {\n      const presences = state[key];\n      if (\"metas\" in presences) {\n        newState[key] = presences.metas.map((presence) => {\n          presence[\"presence_ref\"] = presence[\"phx_ref\"];\n          delete presence[\"phx_ref\"];\n          delete presence[\"phx_ref_prev\"];\n          return presence;\n        });\n      } else {\n        newState[key] = presences;\n      }\n      return newState;\n    }, {});\n  }\n  static cloneDeep(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n  onJoin(callback) {\n    this.caller.onJoin = callback;\n  }\n  onLeave(callback) {\n    this.caller.onLeave = callback;\n  }\n  onSync(callback) {\n    this.caller.onSync = callback;\n  }\n  inPendingSyncState() {\n    return !this.joinRef || this.joinRef !== this.channel._joinRef();\n  }\n};\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\nvar PostgresTypes;\n(function(PostgresTypes2) {\n  PostgresTypes2[\"abstime\"] = \"abstime\";\n  PostgresTypes2[\"bool\"] = \"bool\";\n  PostgresTypes2[\"date\"] = \"date\";\n  PostgresTypes2[\"daterange\"] = \"daterange\";\n  PostgresTypes2[\"float4\"] = \"float4\";\n  PostgresTypes2[\"float8\"] = \"float8\";\n  PostgresTypes2[\"int2\"] = \"int2\";\n  PostgresTypes2[\"int4\"] = \"int4\";\n  PostgresTypes2[\"int4range\"] = \"int4range\";\n  PostgresTypes2[\"int8\"] = \"int8\";\n  PostgresTypes2[\"int8range\"] = \"int8range\";\n  PostgresTypes2[\"json\"] = \"json\";\n  PostgresTypes2[\"jsonb\"] = \"jsonb\";\n  PostgresTypes2[\"money\"] = \"money\";\n  PostgresTypes2[\"numeric\"] = \"numeric\";\n  PostgresTypes2[\"oid\"] = \"oid\";\n  PostgresTypes2[\"reltime\"] = \"reltime\";\n  PostgresTypes2[\"text\"] = \"text\";\n  PostgresTypes2[\"time\"] = \"time\";\n  PostgresTypes2[\"timestamp\"] = \"timestamp\";\n  PostgresTypes2[\"timestamptz\"] = \"timestamptz\";\n  PostgresTypes2[\"timetz\"] = \"timetz\";\n  PostgresTypes2[\"tsrange\"] = \"tsrange\";\n  PostgresTypes2[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\nvar convertChangeData = (columns, record, options = {}) => {\n  var _a;\n  const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n  return Object.keys(record).reduce((acc, rec_key) => {\n    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);\n    return acc;\n  }, {});\n};\nvar convertColumn = (columnName, columns, record, skipTypes) => {\n  const column = columns.find((x) => x.name === columnName);\n  const colType = column === null || column === void 0 ? void 0 : column.type;\n  const value = record[columnName];\n  if (colType && !skipTypes.includes(colType)) {\n    return convertCell(colType, value);\n  }\n  return noop(value);\n};\nvar convertCell = (type, value) => {\n  if (type.charAt(0) === \"_\") {\n    const dataType = type.slice(1, type.length);\n    return toArray(value, dataType);\n  }\n  switch (type) {\n    case PostgresTypes.bool:\n      return toBoolean(value);\n    case PostgresTypes.float4:\n    case PostgresTypes.float8:\n    case PostgresTypes.int2:\n    case PostgresTypes.int4:\n    case PostgresTypes.int8:\n    case PostgresTypes.numeric:\n    case PostgresTypes.oid:\n      return toNumber(value);\n    case PostgresTypes.json:\n    case PostgresTypes.jsonb:\n      return toJson(value);\n    case PostgresTypes.timestamp:\n      return toTimestampString(value);\n    case PostgresTypes.abstime:\n    case PostgresTypes.date:\n    case PostgresTypes.daterange:\n    case PostgresTypes.int4range:\n    case PostgresTypes.int8range:\n    case PostgresTypes.money:\n    case PostgresTypes.reltime:\n    case PostgresTypes.text:\n    case PostgresTypes.time:\n    case PostgresTypes.timestamptz:\n    case PostgresTypes.timetz:\n    case PostgresTypes.tsrange:\n    case PostgresTypes.tstzrange:\n      return noop(value);\n    default:\n      return noop(value);\n  }\n};\nvar noop = (value) => {\n  return value;\n};\nvar toBoolean = (value) => {\n  switch (value) {\n    case \"t\":\n      return true;\n    case \"f\":\n      return false;\n    default:\n      return value;\n  }\n};\nvar toNumber = (value) => {\n  if (typeof value === \"string\") {\n    const parsedValue = parseFloat(value);\n    if (!Number.isNaN(parsedValue)) {\n      return parsedValue;\n    }\n  }\n  return value;\n};\nvar toJson = (value) => {\n  if (typeof value === \"string\") {\n    try {\n      return JSON.parse(value);\n    } catch (error) {\n      console.log(`JSON parse error: ${error}`);\n      return value;\n    }\n  }\n  return value;\n};\nvar toArray = (value, type) => {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  const lastIdx = value.length - 1;\n  const closeBrace = value[lastIdx];\n  const openBrace = value[0];\n  if (openBrace === \"{\" && closeBrace === \"}\") {\n    let arr;\n    const valTrim = value.slice(1, lastIdx);\n    try {\n      arr = JSON.parse(\"[\" + valTrim + \"]\");\n    } catch (_) {\n      arr = valTrim ? valTrim.split(\",\") : [];\n    }\n    return arr.map((val) => convertCell(type, val));\n  }\n  return value;\n};\nvar toTimestampString = (value) => {\n  if (typeof value === \"string\") {\n    return value.replace(\" \", \"T\");\n  }\n  return value;\n};\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\nvar __awaiter4 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2) {\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2[\"ALL\"] = \"*\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2[\"INSERT\"] = \"INSERT\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2[\"UPDATE\"] = \"UPDATE\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nvar REALTIME_LISTEN_TYPES;\n(function(REALTIME_LISTEN_TYPES2) {\n  REALTIME_LISTEN_TYPES2[\"BROADCAST\"] = \"broadcast\";\n  REALTIME_LISTEN_TYPES2[\"PRESENCE\"] = \"presence\";\n  REALTIME_LISTEN_TYPES2[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nvar REALTIME_SUBSCRIBE_STATES;\n(function(REALTIME_SUBSCRIBE_STATES2) {\n  REALTIME_SUBSCRIBE_STATES2[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n  REALTIME_SUBSCRIBE_STATES2[\"TIMED_OUT\"] = \"TIMED_OUT\";\n  REALTIME_SUBSCRIBE_STATES2[\"CLOSED\"] = \"CLOSED\";\n  REALTIME_SUBSCRIBE_STATES2[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nvar RealtimeChannel = class {\n  constructor(topic, params = { config: {} }, socket) {\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = {};\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.params.config = Object.assign({\n      broadcast: { ack: false, self: false },\n      presence: { key: \"\" }\n    }, params.config);\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n    this.joinPush.receive(\"ok\", () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this._onClose(() => {\n      this.rejoinTimer.reset();\n      this.socket.log(\"channel\", `close ${this.topic} ${this._joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket._remove(this);\n    });\n    this._onError((reason) => {\n      if (this._isLeaving() || this._isClosed()) {\n        return;\n      }\n      this.socket.log(\"channel\", `error ${this.topic}`, reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive(\"timeout\", () => {\n      if (!this._isJoining()) {\n        return;\n      }\n      this.socket.log(\"channel\", `timeout ${this.topic}`, this.joinPush.timeout);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n      this._trigger(this._replyEventName(ref), payload);\n    });\n    this.presence = new RealtimePresence(this);\n  }\n  subscribe(callback, timeout = this.timeout) {\n    var _a, _b;\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n    } else {\n      const { config: { broadcast, presence } } = this.params;\n      this._onError((e) => callback && callback(\"CHANNEL_ERROR\", e));\n      this._onClose(() => callback && callback(\"CLOSED\"));\n      const accessTokenPayload = {};\n      const config = {\n        broadcast,\n        presence,\n        postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r) => r.filter)) !== null && _b !== void 0 ? _b : []\n      };\n      if (this.socket.accessToken) {\n        accessTokenPayload.access_token = this.socket.accessToken;\n      }\n      this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));\n      this.joinedOnce = true;\n      this._rejoin(timeout);\n      this.joinPush.receive(\"ok\", ({ postgres_changes: serverPostgresFilters }) => {\n        var _a2;\n        this.socket.accessToken && this.socket.setAuth(this.socket.accessToken);\n        if (serverPostgresFilters === void 0) {\n          callback && callback(\"SUBSCRIBED\");\n          return;\n        } else {\n          const clientPostgresBindings = this.bindings.postgres_changes;\n          const bindingsLen = (_a2 = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a2 !== void 0 ? _a2 : 0;\n          const newPostgresBindings = [];\n          for (let i = 0; i < bindingsLen; i++) {\n            const clientPostgresBinding = clientPostgresBindings[i];\n            const { filter: { event, schema, table, filter } } = clientPostgresBinding;\n            const serverPostgresFilter = serverPostgresFilters && serverPostgresFilters[i];\n            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {\n              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));\n            } else {\n              this.unsubscribe();\n              callback && callback(\"CHANNEL_ERROR\", new Error(\"mismatch between server and client bindings for postgres changes\"));\n              return;\n            }\n          }\n          this.bindings.postgres_changes = newPostgresBindings;\n          callback && callback(\"SUBSCRIBED\");\n          return;\n        }\n      }).receive(\"error\", (error) => {\n        callback && callback(\"CHANNEL_ERROR\", new Error(JSON.stringify(Object.values(error).join(\", \") || \"error\")));\n        return;\n      }).receive(\"timeout\", () => {\n        callback && callback(\"TIMED_OUT\");\n        return;\n      });\n    }\n    return this;\n  }\n  presenceState() {\n    return this.presence.state;\n  }\n  track(payload, opts = {}) {\n    return __awaiter4(this, void 0, void 0, function* () {\n      return yield this.send({\n        type: \"presence\",\n        event: \"track\",\n        payload\n      }, opts.timeout || this.timeout);\n    });\n  }\n  untrack(opts = {}) {\n    return __awaiter4(this, void 0, void 0, function* () {\n      return yield this.send({\n        type: \"presence\",\n        event: \"untrack\"\n      }, opts);\n    });\n  }\n  on(type, filter, callback) {\n    return this._on(type, filter, callback);\n  }\n  send(payload, opts = {}) {\n    return new Promise((resolve) => {\n      var _a, _b, _c;\n      const push = this._push(payload.type, payload, opts.timeout || this.timeout);\n      if (push.rateLimited) {\n        resolve(\"rate limited\");\n      }\n      if (payload.type === \"broadcast\" && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n        resolve(\"ok\");\n      }\n      push.receive(\"ok\", () => resolve(\"ok\"));\n      push.receive(\"timeout\", () => resolve(\"timed out\"));\n    });\n  }\n  updateJoinPayload(payload) {\n    this.joinPush.updatePayload(payload);\n  }\n  unsubscribe(timeout = this.timeout) {\n    this.state = CHANNEL_STATES.leaving;\n    const onClose = () => {\n      this.socket.log(\"channel\", `leave ${this.topic}`);\n      this._trigger(CHANNEL_EVENTS.close, \"leave\", this._joinRef());\n    };\n    this.rejoinTimer.reset();\n    this.joinPush.destroy();\n    return new Promise((resolve) => {\n      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive(\"ok\", () => {\n        onClose();\n        resolve(\"ok\");\n      }).receive(\"timeout\", () => {\n        onClose();\n        resolve(\"timed out\");\n      }).receive(\"error\", () => {\n        resolve(\"error\");\n      });\n      leavePush.send();\n      if (!this._canPush()) {\n        leavePush.trigger(\"ok\", {});\n      }\n    });\n  }\n  _push(event, payload, timeout = this.timeout) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n    }\n    let pushEvent = new Push(this, event, payload, timeout);\n    if (this._canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n    return pushEvent;\n  }\n  _onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  _isMember(topic) {\n    return this.topic === topic;\n  }\n  _joinRef() {\n    return this.joinPush.ref;\n  }\n  _trigger(type, payload, ref) {\n    var _a, _b;\n    const typeLower = type.toLocaleLowerCase();\n    const { close, error, leave, join } = CHANNEL_EVENTS;\n    const events = [close, error, leave, join];\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return;\n    }\n    let handledPayload = this._onMessage(typeLower, payload, ref);\n    if (payload && !handledPayload) {\n      throw \"channel onMessage callbacks must return the payload, modified or unmodified\";\n    }\n    if ([\"insert\", \"update\", \"delete\"].includes(typeLower)) {\n      (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind) => {\n        var _a2, _b2, _c;\n        return ((_a2 = bind.filter) === null || _a2 === void 0 ? void 0 : _a2.event) === \"*\" || ((_c = (_b2 = bind.filter) === null || _b2 === void 0 ? void 0 : _b2.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n      }).map((bind) => bind.callback(handledPayload, ref));\n    } else {\n      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {\n        var _a2, _b2, _c, _d, _e, _f;\n        if ([\"broadcast\", \"presence\", \"postgres_changes\"].includes(typeLower)) {\n          if (\"id\" in bind) {\n            const bindId = bind.id;\n            const bindEvent = (_a2 = bind.filter) === null || _a2 === void 0 ? void 0 : _a2.event;\n            return bindId && ((_b2 = payload.ids) === null || _b2 === void 0 ? void 0 : _b2.includes(bindId)) && (bindEvent === \"*\" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));\n          } else {\n            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n            return bindEvent === \"*\" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n          }\n        } else {\n          return bind.type.toLocaleLowerCase() === typeLower;\n        }\n      }).map((bind) => {\n        if (typeof handledPayload === \"object\" && \"ids\" in handledPayload) {\n          const postgresChanges = handledPayload.data;\n          const { schema, table, commit_timestamp, type: type2, errors } = postgresChanges;\n          const enrichedPayload = {\n            schema,\n            table,\n            commit_timestamp,\n            eventType: type2,\n            new: {},\n            old: {},\n            errors\n          };\n          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n        }\n        bind.callback(handledPayload, ref);\n      });\n    }\n  }\n  _isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  _isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  _isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  _isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n  _replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  _on(type, filter, callback) {\n    const typeLower = type.toLocaleLowerCase();\n    const binding = {\n      type: typeLower,\n      filter,\n      callback\n    };\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding);\n    } else {\n      this.bindings[typeLower] = [binding];\n    }\n    return this;\n  }\n  _off(type, filter) {\n    const typeLower = type.toLocaleLowerCase();\n    this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n      var _a;\n      return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n    });\n    return this;\n  }\n  static isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false;\n    }\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout();\n    if (this.socket.isConnected()) {\n      this._rejoin();\n    }\n  }\n  _onClose(callback) {\n    this._on(CHANNEL_EVENTS.close, {}, callback);\n  }\n  _onError(callback) {\n    this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));\n  }\n  _canPush() {\n    return this.socket.isConnected() && this._isJoined();\n  }\n  _rejoin(timeout = this.timeout) {\n    if (this._isLeaving()) {\n      return;\n    }\n    this.socket._leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  _getPayloadRecords(payload) {\n    const records = {\n      new: {},\n      old: {}\n    };\n    if (payload.type === \"INSERT\" || payload.type === \"UPDATE\") {\n      records.new = convertChangeData(payload.columns, payload.record);\n    }\n    if (payload.type === \"UPDATE\" || payload.type === \"DELETE\") {\n      records.old = convertChangeData(payload.columns, payload.old_record);\n    }\n    return records;\n  }\n};\n\n// node_modules/.pnpm/@supabase+realtime-js@2.1.0/node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\nvar __awaiter5 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar noop2 = () => {\n};\nvar RealtimeClient = class {\n  constructor(endPoint, options) {\n    var _a;\n    this.accessToken = null;\n    this.channels = [];\n    this.endPoint = \"\";\n    this.headers = DEFAULT_HEADERS2;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = import_websocket.w3cwebsocket;\n    this.heartbeatIntervalMs = 3e4;\n    this.heartbeatTimer = void 0;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop2;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.eventsPerSecondLimitMs = 100;\n    this.inThrottle = false;\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    if (options === null || options === void 0 ? void 0 : options.params)\n      this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers)\n      this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout)\n      this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger)\n      this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.transport)\n      this.transport = options.transport;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    const eventsPerSecond = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.eventsPerSecond;\n    if (eventsPerSecond)\n      this.eventsPerSecondLimitMs = Math.floor(1e3 / eventsPerSecond);\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : (tries) => {\n      return [1e3, 2e3, 5e3, 1e4][tries - 1] || 1e4;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer(() => __awaiter5(this, void 0, void 0, function* () {\n      this.disconnect();\n      this.connect();\n    }), this.reconnectAfterMs);\n  }\n  connect() {\n    if (this.conn) {\n      return;\n    }\n    this.conn = new this.transport(this._endPointURL(), [], null, this.headers);\n    if (this.conn) {\n      this.conn.binaryType = \"arraybuffer\";\n      this.conn.onopen = () => this._onConnOpen();\n      this.conn.onerror = (error) => this._onConnError(error);\n      this.conn.onmessage = (event) => this._onConnMessage(event);\n      this.conn.onclose = (event) => this._onConnClose(event);\n    }\n  }\n  disconnect(code, reason) {\n    if (this.conn) {\n      this.conn.onclose = function() {\n      };\n      if (code) {\n        this.conn.close(code, reason !== null && reason !== void 0 ? reason : \"\");\n      } else {\n        this.conn.close();\n      }\n      this.conn = null;\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.reset();\n    }\n  }\n  getChannels() {\n    return this.channels;\n  }\n  removeChannel(channel) {\n    return channel.unsubscribe().then((status) => {\n      if (this.channels.length === 0) {\n        this.disconnect();\n      }\n      return status;\n    });\n  }\n  removeAllChannels() {\n    return Promise.all(this.channels.map((channel) => channel.unsubscribe())).then((values) => {\n      this.disconnect();\n      return values;\n    });\n  }\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting;\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open;\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing;\n      default:\n        return CONNECTION_STATE.Closed;\n    }\n  }\n  isConnected() {\n    return this.connectionState() === CONNECTION_STATE.Open;\n  }\n  channel(topic, params = { config: {} }) {\n    if (!this.isConnected()) {\n      this.connect();\n    }\n    const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n    this.channels.push(chan);\n    return chan;\n  }\n  push(data) {\n    const { topic, event, payload, ref } = data;\n    let callback = () => {\n      this.encode(data, (result) => {\n        var _a;\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n      });\n    };\n    this.log(\"push\", `${topic} ${event} (${ref})`, payload);\n    if (this.isConnected()) {\n      if ([\"broadcast\", \"presence\", \"postgres_changes\"].includes(event)) {\n        const isThrottled = this._throttle(callback)();\n        if (isThrottled) {\n          return \"rate limited\";\n        }\n      } else {\n        callback();\n      }\n    } else {\n      this.sendBuffer.push(callback);\n    }\n  }\n  setAuth(token) {\n    this.accessToken = token;\n    this.channels.forEach((channel) => {\n      token && channel.updateJoinPayload({ access_token: token });\n      if (channel.joinedOnce && channel._isJoined()) {\n        channel._push(CHANNEL_EVENTS.access_token, { access_token: token });\n      }\n    });\n  }\n  _makeRef() {\n    let newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n    return this.ref.toString();\n  }\n  _leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));\n    if (dupChannel) {\n      this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n      dupChannel.unsubscribe();\n    }\n  }\n  _remove(channel) {\n    this.channels = this.channels.filter((c) => c._joinRef() !== channel._joinRef());\n  }\n  _endPointURL() {\n    return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));\n  }\n  _onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, (msg) => {\n      let { topic, event, payload, ref } = msg;\n      if (ref && ref === this.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n        this.pendingHeartbeatRef = null;\n      }\n      this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload);\n      this.channels.filter((channel) => channel._isMember(topic)).forEach((channel) => channel._trigger(event, payload, ref));\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg));\n    });\n  }\n  _onConnOpen() {\n    this.log(\"transport\", `connected to ${this._endPointURL()}`);\n    this._flushSendBuffer();\n    this.reconnectTimer.reset();\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);\n    this.stateChangeCallbacks.open.forEach((callback) => callback());\n  }\n  _onConnClose(event) {\n    this.log(\"transport\", \"close\", event);\n    this._triggerChanError();\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.reconnectTimer.scheduleTimeout();\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event));\n  }\n  _onConnError(error) {\n    this.log(\"transport\", error.message);\n    this._triggerChanError();\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error));\n  }\n  _triggerChanError() {\n    this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));\n  }\n  _appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n    const prefix = url.match(/\\?/) ? \"&\" : \"?\";\n    const query = new URLSearchParams(params);\n    return `${url}${prefix}${query}`;\n  }\n  _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback());\n      this.sendBuffer = [];\n    }\n  }\n  _sendHeartbeat() {\n    var _a;\n    if (!this.isConnected()) {\n      return;\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n      (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, \"hearbeat timeout\");\n      return;\n    }\n    this.pendingHeartbeatRef = this._makeRef();\n    this.push({\n      topic: \"phoenix\",\n      event: \"heartbeat\",\n      payload: {},\n      ref: this.pendingHeartbeatRef\n    });\n    this.setAuth(this.accessToken);\n  }\n  _throttle(callback, eventsPerSecondLimit = this.eventsPerSecondLimitMs) {\n    return () => {\n      if (this.inThrottle)\n        return true;\n      callback();\n      this.inThrottle = true;\n      setTimeout(() => {\n        this.inThrottle = false;\n      }, eventsPerSecondLimit);\n      return false;\n    };\n  }\n};\n\n// node_modules/.pnpm/@supabase+storage-js@2.0.0/node_modules/@supabase/storage-js/dist/module/lib/errors.js\nvar StorageError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.__isStorageError = true;\n    this.name = \"StorageError\";\n  }\n};\nfunction isStorageError(error) {\n  return typeof error === \"object\" && error !== null && \"__isStorageError\" in error;\n}\nvar StorageApiError = class extends StorageError {\n  constructor(message, status) {\n    super(message);\n    this.name = \"StorageApiError\";\n    this.status = status;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status\n    };\n  }\n};\nvar StorageUnknownError = class extends StorageError {\n  constructor(message, originalError) {\n    super(message);\n    this.name = \"StorageUnknownError\";\n    this.originalError = originalError;\n  }\n};\n\n// node_modules/.pnpm/@supabase+storage-js@2.0.0/node_modules/@supabase/storage-js/dist/module/lib/helpers.js\nvar __awaiter6 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar resolveFetch2 = (customFetch) => {\n  let _fetch;\n  if (customFetch) {\n    _fetch = customFetch;\n  } else if (typeof fetch === \"undefined\") {\n    _fetch = (...args) => __awaiter6(void 0, void 0, void 0, function* () {\n      return yield (yield import(\"/node_modules/.vite/deps/browser-ponyfill-T7ISBDOE.js?v=5c95b2a1\")).fetch(...args);\n    });\n  } else {\n    _fetch = fetch;\n  }\n  return (...args) => _fetch(...args);\n};\nvar resolveResponse = () => __awaiter6(void 0, void 0, void 0, function* () {\n  if (typeof Response === \"undefined\") {\n    return (yield import(\"/node_modules/.vite/deps/browser-ponyfill-T7ISBDOE.js?v=5c95b2a1\")).Response;\n  }\n  return Response;\n});\n\n// node_modules/.pnpm/@supabase+storage-js@2.0.0/node_modules/@supabase/storage-js/dist/module/lib/fetch.js\nvar __awaiter7 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nvar handleError = (error, reject) => __awaiter7(void 0, void 0, void 0, function* () {\n  const Res = yield resolveResponse();\n  if (error instanceof Res) {\n    error.json().then((err) => {\n      reject(new StorageApiError(_getErrorMessage(err), error.status || 500));\n    });\n  } else {\n    reject(new StorageUnknownError(_getErrorMessage(error), error));\n  }\n});\nvar _getRequestParams = (method, options, parameters, body) => {\n  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };\n  if (method === \"GET\") {\n    return params;\n  }\n  params.headers = Object.assign({ \"Content-Type\": \"application/json\" }, options === null || options === void 0 ? void 0 : options.headers);\n  params.body = JSON.stringify(body);\n  return Object.assign(Object.assign({}, params), parameters);\n};\nfunction _handleRequest(fetcher, method, url, options, parameters, body) {\n  return __awaiter7(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      fetcher(url, _getRequestParams(method, options, parameters, body)).then((result) => {\n        if (!result.ok)\n          throw result;\n        if (options === null || options === void 0 ? void 0 : options.noResolveJson)\n          return result;\n        return result.json();\n      }).then((data) => resolve(data)).catch((error) => handleError(error, reject));\n    });\n  });\n}\nfunction get(fetcher, url, options, parameters) {\n  return __awaiter7(this, void 0, void 0, function* () {\n    return _handleRequest(fetcher, \"GET\", url, options, parameters);\n  });\n}\nfunction post(fetcher, url, body, options, parameters) {\n  return __awaiter7(this, void 0, void 0, function* () {\n    return _handleRequest(fetcher, \"POST\", url, options, parameters, body);\n  });\n}\nfunction put(fetcher, url, body, options, parameters) {\n  return __awaiter7(this, void 0, void 0, function* () {\n    return _handleRequest(fetcher, \"PUT\", url, options, parameters, body);\n  });\n}\nfunction remove(fetcher, url, body, options, parameters) {\n  return __awaiter7(this, void 0, void 0, function* () {\n    return _handleRequest(fetcher, \"DELETE\", url, options, parameters, body);\n  });\n}\n\n// node_modules/.pnpm/@supabase+storage-js@2.0.0/node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js\nvar __awaiter8 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar DEFAULT_SEARCH_OPTIONS = {\n  limit: 100,\n  offset: 0,\n  sortBy: {\n    column: \"name\",\n    order: \"asc\"\n  }\n};\nvar DEFAULT_FILE_OPTIONS = {\n  cacheControl: \"3600\",\n  contentType: \"text/plain;charset=UTF-8\",\n  upsert: false\n};\nvar StorageFileApi = class {\n  constructor(url, headers = {}, bucketId, fetch2) {\n    this.url = url;\n    this.headers = headers;\n    this.bucketId = bucketId;\n    this.fetch = resolveFetch2(fetch2);\n  }\n  uploadOrUpdate(method, path, fileBody, fileOptions) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      try {\n        let body;\n        const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);\n        const headers = Object.assign(Object.assign({}, this.headers), method === \"POST\" && { \"x-upsert\": String(options.upsert) });\n        if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n          body = new FormData();\n          body.append(\"cacheControl\", options.cacheControl);\n          body.append(\"\", fileBody);\n        } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n          body = fileBody;\n          body.append(\"cacheControl\", options.cacheControl);\n        } else {\n          body = fileBody;\n          headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n          headers[\"content-type\"] = options.contentType;\n        }\n        const cleanPath = this._removeEmptyFolders(path);\n        const _path = this._getFinalPath(cleanPath);\n        const res = yield this.fetch(`${this.url}/object/${_path}`, {\n          method,\n          body,\n          headers\n        });\n        if (res.ok) {\n          return {\n            data: { path: cleanPath },\n            error: null\n          };\n        } else {\n          const error = yield res.json();\n          return { data: null, error };\n        }\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  upload(path, fileBody, fileOptions) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      return this.uploadOrUpdate(\"POST\", path, fileBody, fileOptions);\n    });\n  }\n  update(path, fileBody, fileOptions) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      return this.uploadOrUpdate(\"PUT\", path, fileBody, fileOptions);\n    });\n  }\n  move(fromPath, toPath) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/object/move`, { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath }, { headers: this.headers });\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  copy(fromPath, toPath) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/object/copy`, { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath }, { headers: this.headers });\n        return { data: { path: data.Key }, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  createSignedUrl(path, expiresIn, options) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      try {\n        const _path = this._getFinalPath(path);\n        let data = yield post(this.fetch, `${this.url}/object/sign/${_path}`, { expiresIn }, { headers: this.headers });\n        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n        const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);\n        data = { signedUrl };\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  createSignedUrls(paths, expiresIn, options) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });\n        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n        return {\n          data: data.map((datum) => Object.assign(Object.assign({}, datum), { signedUrl: datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null })),\n          error: null\n        };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  download(path) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      try {\n        const _path = this._getFinalPath(path);\n        const res = yield get(this.fetch, `${this.url}/object/${_path}`, {\n          headers: this.headers,\n          noResolveJson: true\n        });\n        const data = yield res.blob();\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  getPublicUrl(path, options) {\n    const _path = this._getFinalPath(path);\n    const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `?download=${options.download === true ? \"\" : options.download}` : \"\";\n    return {\n      data: { publicUrl: encodeURI(`${this.url}/object/public/${_path}${downloadQueryParam}`) }\n    };\n  }\n  remove(paths) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      try {\n        const data = yield remove(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  list(path, options, parameters) {\n    return __awaiter8(this, void 0, void 0, function* () {\n      try {\n        const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || \"\" });\n        const data = yield post(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, { headers: this.headers }, parameters);\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  _getFinalPath(path) {\n    return `${this.bucketId}/${path}`;\n  }\n  _removeEmptyFolders(path) {\n    return path.replace(/^\\/|\\/$/g, \"\").replace(/\\/+/g, \"/\");\n  }\n};\n\n// node_modules/.pnpm/@supabase+storage-js@2.0.0/node_modules/@supabase/storage-js/dist/module/lib/version.js\nvar version3 = \"2.0.0\";\n\n// node_modules/.pnpm/@supabase+storage-js@2.0.0/node_modules/@supabase/storage-js/dist/module/lib/constants.js\nvar DEFAULT_HEADERS3 = { \"X-Client-Info\": `storage-js/${version3}` };\n\n// node_modules/.pnpm/@supabase+storage-js@2.0.0/node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js\nvar __awaiter9 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar StorageBucketApi = class {\n  constructor(url, headers = {}, fetch2) {\n    this.url = url;\n    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS3), headers);\n    this.fetch = resolveFetch2(fetch2);\n  }\n  listBuckets() {\n    return __awaiter9(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/bucket`, { headers: this.headers });\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  getBucket(id) {\n    return __awaiter9(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers });\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  createBucket(id, options = { public: false }) {\n    return __awaiter9(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/bucket`, { id, name: id, public: options.public }, { headers: this.headers });\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  updateBucket(id, options) {\n    return __awaiter9(this, void 0, void 0, function* () {\n      try {\n        const data = yield put(this.fetch, `${this.url}/bucket/${id}`, { id, name: id, public: options.public }, { headers: this.headers });\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  emptyBucket(id) {\n    return __awaiter9(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  deleteBucket(id) {\n    return __awaiter9(this, void 0, void 0, function* () {\n      try {\n        const data = yield remove(this.fetch, `${this.url}/bucket/${id}`, {}, { headers: this.headers });\n        return { data, error: null };\n      } catch (error) {\n        if (isStorageError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n};\n\n// node_modules/.pnpm/@supabase+storage-js@2.0.0/node_modules/@supabase/storage-js/dist/module/StorageClient.js\nvar StorageClient = class extends StorageBucketApi {\n  constructor(url, headers = {}, fetch2) {\n    super(url, headers, fetch2);\n  }\n  from(id) {\n    return new StorageFileApi(this.url, this.headers, id, this.fetch);\n  }\n};\n\n// node_modules/.pnpm/@supabase+supabase-js@2.1.0/node_modules/@supabase/supabase-js/dist/module/lib/version.js\nvar version4 = \"2.1.0\";\n\n// node_modules/.pnpm/@supabase+supabase-js@2.1.0/node_modules/@supabase/supabase-js/dist/module/lib/constants.js\nvar DEFAULT_HEADERS4 = { \"X-Client-Info\": `supabase-js/${version4}` };\n\n// node_modules/.pnpm/@supabase+supabase-js@2.1.0/node_modules/@supabase/supabase-js/dist/module/lib/fetch.js\nvar import_cross_fetch2 = __toESM(require_browser_ponyfill());\nvar __awaiter10 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar resolveFetch3 = (customFetch) => {\n  let _fetch;\n  if (customFetch) {\n    _fetch = customFetch;\n  } else if (typeof fetch === \"undefined\") {\n    _fetch = import_cross_fetch2.default;\n  } else {\n    _fetch = fetch;\n  }\n  return (...args) => _fetch(...args);\n};\nvar resolveHeadersConstructor = () => {\n  if (typeof Headers === \"undefined\") {\n    return import_cross_fetch2.Headers;\n  }\n  return Headers;\n};\nvar fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {\n  const fetch2 = resolveFetch3(customFetch);\n  const HeadersConstructor = resolveHeadersConstructor();\n  return (input, init) => __awaiter10(void 0, void 0, void 0, function* () {\n    var _a;\n    const accessToken = (_a = yield getAccessToken()) !== null && _a !== void 0 ? _a : supabaseKey;\n    let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n    if (!headers.has(\"apikey\")) {\n      headers.set(\"apikey\", supabaseKey);\n    }\n    if (!headers.has(\"Authorization\")) {\n      headers.set(\"Authorization\", `Bearer ${accessToken}`);\n    }\n    return fetch2(input, Object.assign(Object.assign({}, init), { headers }));\n  });\n};\n\n// node_modules/.pnpm/@supabase+supabase-js@2.1.0/node_modules/@supabase/supabase-js/dist/module/lib/helpers.js\nfunction stripTrailingSlash(url) {\n  return url.replace(/\\/$/, \"\");\n}\nfunction applySettingDefaults(options, defaults) {\n  const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;\n  const { db: DEFAULT_DB_OPTIONS2, auth: DEFAULT_AUTH_OPTIONS2, realtime: DEFAULT_REALTIME_OPTIONS2, global: DEFAULT_GLOBAL_OPTIONS2 } = defaults;\n  return {\n    db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS2), dbOptions),\n    auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS2), authOptions),\n    realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS2), realtimeOptions),\n    global: Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS2), globalOptions)\n  };\n}\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/lib/helpers.js\nvar __awaiter11 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nfunction expiresAt(expiresIn) {\n  const timeNow = Math.round(Date.now() / 1e3);\n  return timeNow + expiresIn;\n}\nfunction uuid() {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 3 | 8;\n    return v.toString(16);\n  });\n}\nvar isBrowser = () => typeof window !== \"undefined\";\nfunction getParameterByName(name, url) {\n  var _a;\n  if (!url)\n    url = ((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.href) || \"\";\n  name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n  const regex = new RegExp(\"[?&#]\" + name + \"(=([^&#]*)|&|#|$)\"), results = regex.exec(url);\n  if (!results)\n    return null;\n  if (!results[2])\n    return \"\";\n  return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n}\nvar resolveFetch4 = (customFetch) => {\n  let _fetch;\n  if (customFetch) {\n    _fetch = customFetch;\n  } else if (typeof fetch === \"undefined\") {\n    _fetch = (...args) => __awaiter11(void 0, void 0, void 0, function* () {\n      return yield (yield import(\"/node_modules/.vite/deps/browser-ponyfill-T7ISBDOE.js?v=5c95b2a1\")).fetch(...args);\n    });\n  } else {\n    _fetch = fetch;\n  }\n  return (...args) => _fetch(...args);\n};\nvar looksLikeFetchResponse = (maybeResponse) => {\n  return typeof maybeResponse === \"object\" && maybeResponse !== null && \"status\" in maybeResponse && \"ok\" in maybeResponse && \"json\" in maybeResponse && typeof maybeResponse.json === \"function\";\n};\nvar setItemAsync = (storage, key, data) => __awaiter11(void 0, void 0, void 0, function* () {\n  yield storage.setItem(key, JSON.stringify(data));\n});\nvar getItemAsync = (storage, key) => __awaiter11(void 0, void 0, void 0, function* () {\n  const value = yield storage.getItem(key);\n  if (!value) {\n    return null;\n  }\n  try {\n    return JSON.parse(value);\n  } catch (_a) {\n    return value;\n  }\n});\nvar removeItemAsync = (storage, key) => __awaiter11(void 0, void 0, void 0, function* () {\n  yield storage.removeItem(key);\n});\nvar decodeBase64URL = (value) => {\n  try {\n    return decodeURIComponent(atob(value.replace(/[-]/g, \"+\").replace(/[_]/g, \"/\")).split(\"\").map((c) => \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2)).join(\"\"));\n  } catch (e) {\n    if (e instanceof ReferenceError) {\n      return Buffer.from(value, \"base64\").toString(\"utf-8\");\n    } else {\n      throw e;\n    }\n  }\n};\nvar Deferred = class {\n  constructor() {\n    ;\n    this.promise = new Deferred.promiseConstructor((res, rej) => {\n      ;\n      this.resolve = res;\n      this.reject = rej;\n    });\n  }\n};\nDeferred.promiseConstructor = Promise;\nfunction decodeJWTPayload(token) {\n  const parts = token.split(\".\");\n  if (parts.length !== 3) {\n    throw new Error(\"JWT is not valid: not a JWT structure\");\n  }\n  const base64Url = parts[1];\n  return JSON.parse(decodeBase64URL(base64Url));\n}\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/lib/errors.js\nvar AuthError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.__isAuthError = true;\n    this.name = \"AuthError\";\n  }\n};\nfunction isAuthError(error) {\n  return typeof error === \"object\" && error !== null && \"__isAuthError\" in error;\n}\nvar AuthApiError = class extends AuthError {\n  constructor(message, status) {\n    super(message);\n    this.name = \"AuthApiError\";\n    this.status = status;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status\n    };\n  }\n};\nvar AuthUnknownError = class extends AuthError {\n  constructor(message, originalError) {\n    super(message);\n    this.name = \"AuthUnknownError\";\n    this.originalError = originalError;\n  }\n};\nvar CustomAuthError = class extends AuthError {\n  constructor(message, name, status) {\n    super(message);\n    this.name = name;\n    this.status = status;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status\n    };\n  }\n};\nvar AuthSessionMissingError = class extends CustomAuthError {\n  constructor() {\n    super(\"Auth session missing!\", \"AuthSessionMissingError\", 400);\n  }\n};\nvar AuthInvalidCredentialsError = class extends CustomAuthError {\n  constructor(message) {\n    super(message, \"AuthInvalidCredentialsError\", 400);\n  }\n};\nvar AuthImplicitGrantRedirectError = class extends CustomAuthError {\n  constructor(message, details = null) {\n    super(message, \"AuthImplicitGrantRedirectError\", 500);\n    this.details = null;\n    this.details = details;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n      details: this.details\n    };\n  }\n};\nvar AuthRetryableFetchError = class extends CustomAuthError {\n  constructor(message, status) {\n    super(message, \"AuthRetryableFetchError\", status);\n  }\n};\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/lib/fetch.js\nvar __awaiter12 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = function(s, e) {\n  var t = {};\n  for (var p in s)\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n        t[p[i]] = s[p[i]];\n    }\n  return t;\n};\nvar _getErrorMessage2 = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nvar handleError2 = (error, reject) => __awaiter12(void 0, void 0, void 0, function* () {\n  const NETWORK_ERROR_CODES = [502, 503, 504];\n  if (!looksLikeFetchResponse(error)) {\n    reject(new AuthRetryableFetchError(_getErrorMessage2(error), 0));\n  } else if (NETWORK_ERROR_CODES.includes(error.status)) {\n    reject(new AuthRetryableFetchError(_getErrorMessage2(error), error.status));\n  } else {\n    error.json().then((err) => {\n      reject(new AuthApiError(_getErrorMessage2(err), error.status || 500));\n    }).catch((e) => {\n      reject(new AuthUnknownError(_getErrorMessage2(e), e));\n    });\n  }\n});\nvar _getRequestParams2 = (method, options, parameters, body) => {\n  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };\n  if (method === \"GET\") {\n    return params;\n  }\n  params.headers = Object.assign({ \"Content-Type\": \"application/json;charset=UTF-8\" }, options === null || options === void 0 ? void 0 : options.headers);\n  params.body = JSON.stringify(body);\n  return Object.assign(Object.assign({}, params), parameters);\n};\nfunction _request(fetcher, method, url, options) {\n  var _a, _b;\n  return __awaiter12(this, void 0, void 0, function* () {\n    const headers = (_a = options === null || options === void 0 ? void 0 : options.headers) !== null && _a !== void 0 ? _a : {};\n    if (options === null || options === void 0 ? void 0 : options.jwt) {\n      headers[\"Authorization\"] = `Bearer ${options.jwt}`;\n    }\n    const qs = (_b = options === null || options === void 0 ? void 0 : options.query) !== null && _b !== void 0 ? _b : {};\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n      qs[\"redirect_to\"] = options.redirectTo;\n    }\n    const queryString = Object.keys(qs).length ? \"?\" + new URLSearchParams(qs).toString() : \"\";\n    const data = yield _handleRequest2(fetcher, method, url + queryString, { headers, noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson }, {}, options === null || options === void 0 ? void 0 : options.body);\n    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };\n  });\n}\nfunction _handleRequest2(fetcher, method, url, options, parameters, body) {\n  return __awaiter12(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      fetcher(url, _getRequestParams2(method, options, parameters, body)).then((result) => {\n        if (!result.ok)\n          throw result;\n        if (options === null || options === void 0 ? void 0 : options.noResolveJson)\n          return result;\n        return result.json();\n      }).then((data) => resolve(data)).catch((error) => handleError2(error, reject));\n    });\n  });\n}\nfunction _sessionResponse(data) {\n  var _a;\n  let session = null;\n  if (hasSession(data)) {\n    session = Object.assign({}, data);\n    session.expires_at = expiresAt(data.expires_in);\n  }\n  const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n  return { data: { session, user }, error: null };\n}\nfunction _userResponse(data) {\n  var _a;\n  const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n  return { data: { user }, error: null };\n}\nfunction _ssoResponse(data) {\n  return { data, error: null };\n}\nfunction _generateLinkResponse(data) {\n  const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, [\"action_link\", \"email_otp\", \"hashed_token\", \"redirect_to\", \"verification_type\"]);\n  const properties = {\n    action_link,\n    email_otp,\n    hashed_token,\n    redirect_to,\n    verification_type\n  };\n  const user = Object.assign({}, rest);\n  return {\n    data: {\n      properties,\n      user\n    },\n    error: null\n  };\n}\nfunction hasSession(data) {\n  return data.access_token && data.refresh_token && data.expires_in;\n}\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/GoTrueAdminApi.js\nvar __awaiter13 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest2 = function(s, e) {\n  var t = {};\n  for (var p in s)\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n        t[p[i]] = s[p[i]];\n    }\n  return t;\n};\nvar GoTrueAdminApi = class {\n  constructor({ url = \"\", headers = {}, fetch: fetch2 }) {\n    this.url = url;\n    this.headers = headers;\n    this.fetch = resolveFetch4(fetch2);\n    this.mfa = {\n      listFactors: this._listFactors.bind(this),\n      deleteFactor: this._deleteFactor.bind(this)\n    };\n  }\n  signOut(jwt) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        yield _request(this.fetch, \"POST\", `${this.url}/logout`, {\n          headers: this.headers,\n          jwt,\n          noResolveJson: true\n        });\n        return { data: null, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  inviteUserByEmail(email, options = {}) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, \"POST\", `${this.url}/invite`, {\n          body: { email, data: options.data },\n          headers: this.headers,\n          redirectTo: options.redirectTo,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  generateLink(params) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        const { options } = params, rest = __rest2(params, [\"options\"]);\n        const body = Object.assign(Object.assign({}, rest), options);\n        if (\"newEmail\" in rest) {\n          body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;\n          delete body[\"newEmail\"];\n        }\n        return yield _request(this.fetch, \"POST\", `${this.url}/admin/generate_link`, {\n          body,\n          headers: this.headers,\n          xform: _generateLinkResponse,\n          redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              properties: null,\n              user: null\n            },\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  createUser(attributes) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, \"POST\", `${this.url}/admin/users`, {\n          body: attributes,\n          headers: this.headers,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  listUsers() {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        const { data, error } = yield _request(this.fetch, \"GET\", `${this.url}/admin/users`, {\n          headers: this.headers\n        });\n        if (error)\n          throw error;\n        return { data: Object.assign({}, data), error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { users: [] }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  getUserById(uid) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, \"GET\", `${this.url}/admin/users/${uid}`, {\n          headers: this.headers,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  updateUserById(uid, attributes) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, \"PUT\", `${this.url}/admin/users/${uid}`, {\n          body: attributes,\n          headers: this.headers,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  deleteUser(id) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, \"DELETE\", `${this.url}/admin/users/${id}`, {\n          headers: this.headers,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  _listFactors(params) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        const data = yield _request(this.fetch, \"GET\", `${this.url}/admin/users/${params.userId}/factors`, {\n          headers: this.headers\n        });\n        return { data, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  _deleteFactor(params) {\n    return __awaiter13(this, void 0, void 0, function* () {\n      try {\n        const data = yield _request(this.fetch, \"DELETE\", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {\n          headers: this.headers\n        });\n        return { data, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n};\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/lib/version.js\nvar version5 = \"2.3.0\";\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/lib/constants.js\nvar GOTRUE_URL = \"http://localhost:9999\";\nvar STORAGE_KEY = \"supabase.auth.token\";\nvar DEFAULT_HEADERS5 = { \"X-Client-Info\": `gotrue-js/${version5}` };\nvar EXPIRY_MARGIN = 10;\nvar NETWORK_FAILURE = {\n  MAX_RETRIES: 10,\n  RETRY_INTERVAL: 2\n};\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/lib/local-storage.js\nvar localStorageAdapter = {\n  getItem: (key) => {\n    if (!isBrowser()) {\n      return null;\n    }\n    return globalThis.localStorage.getItem(key);\n  },\n  setItem: (key, value) => {\n    if (!isBrowser()) {\n      return;\n    }\n    globalThis.localStorage.setItem(key, value);\n  },\n  removeItem: (key) => {\n    if (!isBrowser()) {\n      return;\n    }\n    globalThis.localStorage.removeItem(key);\n  }\n};\nvar local_storage_default = localStorageAdapter;\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/lib/polyfills.js\nfunction polyfillGlobalThis() {\n  if (typeof globalThis === \"object\")\n    return;\n  try {\n    Object.defineProperty(Object.prototype, \"__magic__\", {\n      get: function() {\n        return this;\n      },\n      configurable: true\n    });\n    __magic__.globalThis = __magic__;\n    delete Object.prototype.__magic__;\n  } catch (e) {\n    if (typeof self !== \"undefined\") {\n      self.globalThis = self;\n    }\n  }\n}\n\n// node_modules/.pnpm/@supabase+gotrue-js@2.3.0/node_modules/@supabase/gotrue-js/dist/module/GoTrueClient.js\nvar __awaiter14 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\npolyfillGlobalThis();\nvar DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS5\n};\nvar GoTrueClient = class {\n  constructor(options) {\n    this.stateChangeEmitters = /* @__PURE__ */ new Map();\n    this.networkRetries = 0;\n    this.refreshingDeferred = null;\n    this.initializePromise = null;\n    this.detectSessionInUrl = true;\n    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.inMemorySession = null;\n    this.storageKey = settings.storageKey;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.storage = settings.storage || local_storage_default;\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch\n    });\n    this.url = settings.url;\n    this.headers = settings.headers;\n    this.fetch = resolveFetch4(settings.fetch);\n    this.detectSessionInUrl = settings.detectSessionInUrl;\n    this.initialize();\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)\n    };\n  }\n  initialize() {\n    if (!this.initializePromise) {\n      this.initializePromise = this._initialize();\n    }\n    return this.initializePromise;\n  }\n  _initialize() {\n    return __awaiter14(this, void 0, void 0, function* () {\n      if (this.initializePromise) {\n        return this.initializePromise;\n      }\n      try {\n        if (this.detectSessionInUrl && this._isImplicitGrantFlow()) {\n          const { data, error } = yield this._getSessionFromUrl();\n          if (error) {\n            yield this._removeSession();\n            return { error };\n          }\n          const { session, redirectType } = data;\n          yield this._saveSession(session);\n          this._notifyAllSubscribers(\"SIGNED_IN\", session);\n          if (redirectType === \"recovery\") {\n            this._notifyAllSubscribers(\"PASSWORD_RECOVERY\", session);\n          }\n          return { error: null };\n        }\n        yield this._recoverAndRefresh();\n        return { error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { error };\n        }\n        return {\n          error: new AuthUnknownError(\"Unexpected error during initialization\", error)\n        };\n      } finally {\n        this._handleVisibilityChange();\n      }\n    });\n  }\n  signUp(credentials) {\n    var _a, _b;\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        let res;\n        if (\"email\" in credentials) {\n          const { email, password, options } = credentials;\n          res = yield _request(this.fetch, \"POST\", `${this.url}/signup`, {\n            headers: this.headers,\n            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n            body: {\n              email,\n              password,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }\n            },\n            xform: _sessionResponse\n          });\n        } else if (\"phone\" in credentials) {\n          const { phone, password, options } = credentials;\n          res = yield _request(this.fetch, \"POST\", `${this.url}/signup`, {\n            headers: this.headers,\n            body: {\n              phone,\n              password,\n              data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }\n            },\n            xform: _sessionResponse\n          });\n        } else {\n          throw new AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n        }\n        const { data, error } = res;\n        if (error || !data) {\n          return { data: { user: null, session: null }, error };\n        }\n        const session = data.session;\n        const user = data.user;\n        if (data.session) {\n          yield this._saveSession(data.session);\n          this._notifyAllSubscribers(\"SIGNED_IN\", session);\n        }\n        return { data: { user, session }, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null, session: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  signInWithPassword(credentials) {\n    var _a, _b;\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        let res;\n        if (\"email\" in credentials) {\n          const { email, password, options } = credentials;\n          res = yield _request(this.fetch, \"POST\", `${this.url}/token?grant_type=password`, {\n            headers: this.headers,\n            body: {\n              email,\n              password,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }\n            },\n            xform: _sessionResponse\n          });\n        } else if (\"phone\" in credentials) {\n          const { phone, password, options } = credentials;\n          res = yield _request(this.fetch, \"POST\", `${this.url}/token?grant_type=password`, {\n            headers: this.headers,\n            body: {\n              phone,\n              password,\n              data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }\n            },\n            xform: _sessionResponse\n          });\n        } else {\n          throw new AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n        }\n        const { data, error } = res;\n        if (error || !data)\n          return { data: { user: null, session: null }, error };\n        if (data.session) {\n          yield this._saveSession(data.session);\n          this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n        }\n        return { data, error };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null, session: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  signInWithOAuth(credentials) {\n    var _a, _b, _c;\n    return __awaiter14(this, void 0, void 0, function* () {\n      yield this._removeSession();\n      return this._handleProviderSignIn(credentials.provider, {\n        redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n        scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n        queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams\n      });\n    });\n  }\n  signInWithOtp(credentials) {\n    var _a, _b, _c, _d;\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        if (\"email\" in credentials) {\n          const { email, options } = credentials;\n          const { error } = yield _request(this.fetch, \"POST\", `${this.url}/otp`, {\n            headers: this.headers,\n            body: {\n              email,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }\n            },\n            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n          });\n          return { data: { user: null, session: null }, error };\n        }\n        if (\"phone\" in credentials) {\n          const { phone, options } = credentials;\n          const { error } = yield _request(this.fetch, \"POST\", `${this.url}/otp`, {\n            headers: this.headers,\n            body: {\n              phone,\n              data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n              create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }\n            }\n          });\n          return { data: { user: null, session: null }, error };\n        }\n        throw new AuthInvalidCredentialsError(\"You must provide either an email or phone number.\");\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null, session: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  verifyOtp(params) {\n    var _a, _b;\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        const { data, error } = yield _request(this.fetch, \"POST\", `${this.url}/verify`, {\n          headers: this.headers,\n          body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken } }),\n          redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n          xform: _sessionResponse\n        });\n        if (error) {\n          throw error;\n        }\n        if (!data) {\n          throw \"An error occurred on token verification.\";\n        }\n        const session = data.session;\n        const user = data.user;\n        if (session === null || session === void 0 ? void 0 : session.access_token) {\n          yield this._saveSession(session);\n          this._notifyAllSubscribers(\"SIGNED_IN\", session);\n        }\n        return { data: { user, session }, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null, session: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  signInWithSSO(params) {\n    var _a, _b, _c;\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        return yield _request(this.fetch, \"POST\", `${this.url}/sso`, {\n          body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, \"providerId\" in params ? { provider_id: params.providerId } : null), \"domain\" in params ? { domain: params.domain } : null), { redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : void 0 }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } } : null), { skip_http_redirect: true }),\n          headers: this.headers,\n          xform: _ssoResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  getSession() {\n    return __awaiter14(this, void 0, void 0, function* () {\n      yield this.initializePromise;\n      let currentSession = null;\n      if (this.persistSession) {\n        const maybeSession = yield getItemAsync(this.storage, this.storageKey);\n        if (maybeSession !== null) {\n          if (this._isValidSession(maybeSession)) {\n            currentSession = maybeSession;\n          } else {\n            yield this._removeSession();\n          }\n        }\n      } else {\n        currentSession = this.inMemorySession;\n      }\n      if (!currentSession) {\n        return { data: { session: null }, error: null };\n      }\n      const hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1e3 : false;\n      if (!hasExpired) {\n        return { data: { session: currentSession }, error: null };\n      }\n      const { session, error } = yield this._callRefreshToken(currentSession.refresh_token);\n      if (error) {\n        return { data: { session: null }, error };\n      }\n      return { data: { session }, error: null };\n    });\n  }\n  getUser(jwt) {\n    var _a, _b;\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        if (!jwt) {\n          const { data, error } = yield this.getSession();\n          if (error) {\n            throw error;\n          }\n          jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : void 0;\n        }\n        return yield _request(this.fetch, \"GET\", `${this.url}/user`, {\n          headers: this.headers,\n          jwt,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  updateUser(attributes) {\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        const { data: sessionData, error: sessionError } = yield this.getSession();\n        if (sessionError) {\n          throw sessionError;\n        }\n        if (!sessionData.session) {\n          throw new AuthSessionMissingError();\n        }\n        const session = sessionData.session;\n        const { data, error: userError } = yield _request(this.fetch, \"PUT\", `${this.url}/user`, {\n          headers: this.headers,\n          body: attributes,\n          jwt: session.access_token,\n          xform: _userResponse\n        });\n        if (userError)\n          throw userError;\n        session.user = data.user;\n        yield this._saveSession(session);\n        this._notifyAllSubscribers(\"USER_UPDATED\", session);\n        return { data: { user: session.user }, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  _decodeJWT(jwt) {\n    return decodeJWTPayload(jwt);\n  }\n  setSession(currentSession) {\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        const timeNow = Date.now() / 1e3;\n        let expiresAt2 = timeNow;\n        let hasExpired = true;\n        let session = null;\n        if (currentSession.access_token && currentSession.access_token.split(\".\")[1]) {\n          const payload = this._decodeJWT(currentSession.access_token);\n          if (payload.exp) {\n            expiresAt2 = payload.exp;\n            hasExpired = expiresAt2 <= timeNow;\n          }\n        }\n        if (hasExpired) {\n          if (!currentSession.refresh_token) {\n            throw new AuthSessionMissingError();\n          }\n          const { data, error } = yield this._refreshAccessToken(currentSession.refresh_token);\n          if (error) {\n            return { data: { session: null, user: null }, error };\n          }\n          if (!data.session) {\n            return { data: { session: null, user: null }, error: null };\n          }\n          session = data.session;\n        } else {\n          const { data, error } = yield this.getUser(currentSession.access_token);\n          if (error) {\n            throw error;\n          }\n          session = {\n            access_token: currentSession.access_token,\n            refresh_token: currentSession.refresh_token,\n            user: data.user,\n            token_type: \"bearer\",\n            expires_in: expiresAt2 - timeNow,\n            expires_at: expiresAt2\n          };\n        }\n        yield this._saveSession(session);\n        this._notifyAllSubscribers(\"TOKEN_REFRESHED\", session);\n        return { data: { session, user: session.user }, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { session: null, user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  refreshSession(currentSession) {\n    var _a;\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        if (!currentSession) {\n          const { data, error: error2 } = yield this.getSession();\n          if (error2) {\n            throw error2;\n          }\n          currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : void 0;\n        }\n        if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n          throw new AuthSessionMissingError();\n        }\n        const { session, error } = yield this._callRefreshToken(currentSession.refresh_token);\n        if (error) {\n          return { data: { user: null, session: null }, error };\n        }\n        if (!session) {\n          return { data: { user: null, session: null }, error: null };\n        }\n        return { data: { user: session.user, session }, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { user: null, session: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  _getSessionFromUrl() {\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        if (!isBrowser())\n          throw new AuthImplicitGrantRedirectError(\"No browser detected.\");\n        if (!this._isImplicitGrantFlow()) {\n          throw new AuthImplicitGrantRedirectError(\"Not a valid implicit grant flow url.\");\n        }\n        const error_description = getParameterByName(\"error_description\");\n        if (error_description) {\n          const error_code = getParameterByName(\"error_code\");\n          if (!error_code)\n            throw new AuthImplicitGrantRedirectError(\"No error_code detected.\");\n          const error2 = getParameterByName(\"error\");\n          if (!error2)\n            throw new AuthImplicitGrantRedirectError(\"No error detected.\");\n          throw new AuthImplicitGrantRedirectError(error_description, { error: error2, code: error_code });\n        }\n        const provider_token = getParameterByName(\"provider_token\");\n        const provider_refresh_token = getParameterByName(\"provider_refresh_token\");\n        const access_token = getParameterByName(\"access_token\");\n        if (!access_token)\n          throw new AuthImplicitGrantRedirectError(\"No access_token detected.\");\n        const expires_in = getParameterByName(\"expires_in\");\n        if (!expires_in)\n          throw new AuthImplicitGrantRedirectError(\"No expires_in detected.\");\n        const refresh_token = getParameterByName(\"refresh_token\");\n        if (!refresh_token)\n          throw new AuthImplicitGrantRedirectError(\"No refresh_token detected.\");\n        const token_type = getParameterByName(\"token_type\");\n        if (!token_type)\n          throw new AuthImplicitGrantRedirectError(\"No token_type detected.\");\n        const timeNow = Math.round(Date.now() / 1e3);\n        const expires_at = timeNow + parseInt(expires_in);\n        const { data, error } = yield this.getUser(access_token);\n        if (error)\n          throw error;\n        const user = data.user;\n        const session = {\n          provider_token,\n          provider_refresh_token,\n          access_token,\n          expires_in: parseInt(expires_in),\n          expires_at,\n          refresh_token,\n          token_type,\n          user\n        };\n        const redirectType = getParameterByName(\"type\");\n        window.location.hash = \"\";\n        return { data: { session, redirectType }, error: null };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { session: null, redirectType: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  _isImplicitGrantFlow() {\n    return isBrowser() && (Boolean(getParameterByName(\"access_token\")) || Boolean(getParameterByName(\"error_description\")));\n  }\n  signOut() {\n    var _a;\n    return __awaiter14(this, void 0, void 0, function* () {\n      const { data, error: sessionError } = yield this.getSession();\n      if (sessionError) {\n        return { error: sessionError };\n      }\n      const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n      if (accessToken) {\n        const { error } = yield this.admin.signOut(accessToken);\n        if (error)\n          return { error };\n      }\n      yield this._removeSession();\n      this._notifyAllSubscribers(\"SIGNED_OUT\", null);\n      return { error: null };\n    });\n  }\n  onAuthStateChange(callback) {\n    const id = uuid();\n    const subscription = {\n      id,\n      callback,\n      unsubscribe: () => {\n        this.stateChangeEmitters.delete(id);\n      }\n    };\n    this.stateChangeEmitters.set(id, subscription);\n    return { data: { subscription } };\n  }\n  resetPasswordForEmail(email, options = {}) {\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, \"POST\", `${this.url}/recover`, {\n          body: { email, gotrue_meta_security: { captcha_token: options.captchaToken } },\n          headers: this.headers,\n          redirectTo: options.redirectTo\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: null, error };\n        }\n        throw error;\n      }\n    });\n  }\n  _refreshAccessToken(refreshToken) {\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, \"POST\", `${this.url}/token?grant_type=refresh_token`, {\n          body: { refresh_token: refreshToken },\n          headers: this.headers,\n          xform: _sessionResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: { session: null, user: null }, error };\n        }\n        throw error;\n      }\n    });\n  }\n  _isValidSession(maybeSession) {\n    const isValidSession = typeof maybeSession === \"object\" && maybeSession !== null && \"access_token\" in maybeSession && \"refresh_token\" in maybeSession && \"expires_at\" in maybeSession;\n    return isValidSession;\n  }\n  _handleProviderSignIn(provider, options = {}) {\n    const url = this._getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams\n    });\n    if (isBrowser()) {\n      window.location.href = url;\n    }\n    return { data: { provider, url }, error: null };\n  }\n  _recoverAndRefresh() {\n    var _a;\n    return __awaiter14(this, void 0, void 0, function* () {\n      try {\n        const currentSession = yield getItemAsync(this.storage, this.storageKey);\n        if (!this._isValidSession(currentSession)) {\n          if (currentSession !== null) {\n            yield this._removeSession();\n          }\n          return;\n        }\n        const timeNow = Math.round(Date.now() / 1e3);\n        if (((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN) {\n          if (this.autoRefreshToken && currentSession.refresh_token) {\n            this.networkRetries++;\n            const { error } = yield this._callRefreshToken(currentSession.refresh_token);\n            if (error) {\n              console.log(error.message);\n              if (error instanceof AuthRetryableFetchError && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) {\n                if (this.refreshTokenTimer)\n                  clearTimeout(this.refreshTokenTimer);\n                this.refreshTokenTimer = setTimeout(\n                  () => this._recoverAndRefresh(),\n                  Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100\n                );\n                return;\n              }\n              yield this._removeSession();\n            }\n            this.networkRetries = 0;\n          } else {\n            yield this._removeSession();\n          }\n        } else {\n          if (this.persistSession) {\n            yield this._saveSession(currentSession);\n          }\n          this._notifyAllSubscribers(\"SIGNED_IN\", currentSession);\n        }\n      } catch (err) {\n        console.error(err);\n        return;\n      }\n    });\n  }\n  _callRefreshToken(refreshToken) {\n    var _a, _b;\n    return __awaiter14(this, void 0, void 0, function* () {\n      if (this.refreshingDeferred) {\n        return this.refreshingDeferred.promise;\n      }\n      try {\n        this.refreshingDeferred = new Deferred();\n        if (!refreshToken) {\n          throw new AuthSessionMissingError();\n        }\n        const { data, error } = yield this._refreshAccessToken(refreshToken);\n        if (error)\n          throw error;\n        if (!data.session)\n          throw new AuthSessionMissingError();\n        yield this._saveSession(data.session);\n        this._notifyAllSubscribers(\"TOKEN_REFRESHED\", data.session);\n        const result = { session: data.session, error: null };\n        this.refreshingDeferred.resolve(result);\n        return result;\n      } catch (error) {\n        if (isAuthError(error)) {\n          const result = { session: null, error };\n          (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n          return result;\n        }\n        (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n        throw error;\n      } finally {\n        this.refreshingDeferred = null;\n      }\n    });\n  }\n  _notifyAllSubscribers(event, session) {\n    this.stateChangeEmitters.forEach((x) => x.callback(event, session));\n  }\n  _saveSession(session) {\n    return __awaiter14(this, void 0, void 0, function* () {\n      if (!this.persistSession) {\n        this.inMemorySession = session;\n      }\n      const expiresAt2 = session.expires_at;\n      if (expiresAt2) {\n        const timeNow = Math.round(Date.now() / 1e3);\n        const expiresIn = expiresAt2 - timeNow;\n        const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n        this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1e3);\n      }\n      if (this.persistSession && session.expires_at) {\n        yield this._persistSession(session);\n      }\n    });\n  }\n  _persistSession(currentSession) {\n    return setItemAsync(this.storage, this.storageKey, currentSession);\n  }\n  _removeSession() {\n    return __awaiter14(this, void 0, void 0, function* () {\n      if (this.persistSession) {\n        yield removeItemAsync(this.storage, this.storageKey);\n      } else {\n        this.inMemorySession = null;\n      }\n      if (this.refreshTokenTimer) {\n        clearTimeout(this.refreshTokenTimer);\n      }\n    });\n  }\n  _startAutoRefreshToken(value) {\n    if (this.refreshTokenTimer)\n      clearTimeout(this.refreshTokenTimer);\n    if (value <= 0 || !this.autoRefreshToken)\n      return;\n    this.refreshTokenTimer = setTimeout(() => __awaiter14(this, void 0, void 0, function* () {\n      this.networkRetries++;\n      const { data: { session }, error: sessionError } = yield this.getSession();\n      if (!sessionError && session) {\n        const { error } = yield this._callRefreshToken(session.refresh_token);\n        if (!error)\n          this.networkRetries = 0;\n        if (error instanceof AuthRetryableFetchError && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES)\n          this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100);\n      }\n    }), value);\n    if (typeof this.refreshTokenTimer.unref === \"function\")\n      this.refreshTokenTimer.unref();\n  }\n  _handleVisibilityChange() {\n    if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n      return false;\n    }\n    try {\n      window === null || window === void 0 ? void 0 : window.addEventListener(\"visibilitychange\", () => __awaiter14(this, void 0, void 0, function* () {\n        if (document.visibilityState === \"visible\") {\n          yield this.initializePromise;\n          yield this._recoverAndRefresh();\n        }\n      }));\n    } catch (error) {\n      console.error(\"_handleVisibilityChange\", error);\n    }\n  }\n  _getUrlForProvider(provider, options) {\n    const urlParams = [`provider=${encodeURIComponent(provider)}`];\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n    }\n    if (options === null || options === void 0 ? void 0 : options.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n    }\n    if (options === null || options === void 0 ? void 0 : options.queryParams) {\n      const query = new URLSearchParams(options.queryParams);\n      urlParams.push(query.toString());\n    }\n    return `${this.url}/authorize?${urlParams.join(\"&\")}`;\n  }\n  _unenroll(params) {\n    var _a;\n    return __awaiter14(this, void 0, void 0, function* () {\n      const { data: sessionData, error: sessionError } = yield this.getSession();\n      if (sessionError) {\n        return { data: null, error: sessionError };\n      }\n      return yield _request(this.fetch, \"DELETE\", `${this.url}/factors/${params.factorId}`, {\n        headers: this.headers,\n        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n      });\n    });\n  }\n  _enroll(params) {\n    var _a, _b;\n    return __awaiter14(this, void 0, void 0, function* () {\n      const { data: sessionData, error: sessionError } = yield this.getSession();\n      if (sessionError) {\n        return { data: null, error: sessionError };\n      }\n      const { data, error } = yield _request(this.fetch, \"POST\", `${this.url}/factors`, {\n        body: {\n          friendly_name: params.friendlyName,\n          factor_type: params.factorType,\n          issuer: params.issuer\n        },\n        headers: this.headers,\n        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n      });\n      if (error) {\n        return { data: null, error };\n      }\n      if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {\n        data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n      }\n      return { data, error: null };\n    });\n  }\n  _verify(params) {\n    var _a;\n    return __awaiter14(this, void 0, void 0, function* () {\n      const { data: sessionData, error: sessionError } = yield this.getSession();\n      if (sessionError) {\n        return { data: null, error: sessionError };\n      }\n      const { data, error } = yield _request(this.fetch, \"POST\", `${this.url}/factors/${params.factorId}/verify`, {\n        body: { code: params.code, challenge_id: params.challengeId },\n        headers: this.headers,\n        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n      });\n      if (error) {\n        return { data: null, error };\n      }\n      yield this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + data.expires_in }, data));\n      this._notifyAllSubscribers(\"MFA_CHALLENGE_VERIFIED\", data);\n      return { data, error };\n    });\n  }\n  _challenge(params) {\n    var _a;\n    return __awaiter14(this, void 0, void 0, function* () {\n      const { data: sessionData, error: sessionError } = yield this.getSession();\n      if (sessionError) {\n        return { data: null, error: sessionError };\n      }\n      return yield _request(this.fetch, \"POST\", `${this.url}/factors/${params.factorId}/challenge`, {\n        headers: this.headers,\n        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n      });\n    });\n  }\n  _challengeAndVerify(params) {\n    return __awaiter14(this, void 0, void 0, function* () {\n      const { data: challengeData, error: challengeError } = yield this._challenge({\n        factorId: params.factorId\n      });\n      if (challengeError) {\n        return { data: null, error: challengeError };\n      }\n      return yield this._verify({\n        factorId: params.factorId,\n        challengeId: challengeData.id,\n        code: params.code\n      });\n    });\n  }\n  _listFactors() {\n    return __awaiter14(this, void 0, void 0, function* () {\n      const { data: { user }, error: userError } = yield this.getUser();\n      if (userError) {\n        return { data: null, error: userError };\n      }\n      const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n      const totp = factors.filter((factor) => factor.factor_type === \"totp\" && factor.status === \"verified\");\n      return {\n        data: {\n          all: factors,\n          totp\n        },\n        error: null\n      };\n    });\n  }\n  _getAuthenticatorAssuranceLevel() {\n    var _a, _b;\n    return __awaiter14(this, void 0, void 0, function* () {\n      const { data: { session }, error: sessionError } = yield this.getSession();\n      if (sessionError) {\n        return { data: null, error: sessionError };\n      }\n      if (!session) {\n        return {\n          data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\n          error: null\n        };\n      }\n      const payload = this._decodeJWT(session.access_token);\n      let currentLevel = null;\n      if (payload.aal) {\n        currentLevel = payload.aal;\n      }\n      let nextLevel = currentLevel;\n      const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter((factor) => factor.status === \"verified\")) !== null && _b !== void 0 ? _b : [];\n      if (verifiedFactors.length > 0) {\n        nextLevel = \"aal2\";\n      }\n      const currentAuthenticationMethods = payload.amr || [];\n      return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };\n    });\n  }\n};\n\n// node_modules/.pnpm/@supabase+supabase-js@2.1.0/node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js\nvar SupabaseAuthClient = class extends GoTrueClient {\n  constructor(options) {\n    super(options);\n  }\n};\n\n// node_modules/.pnpm/@supabase+supabase-js@2.1.0/node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js\nvar __awaiter15 = function(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar DEFAULT_GLOBAL_OPTIONS = {\n  headers: DEFAULT_HEADERS4\n};\nvar DEFAULT_DB_OPTIONS = {\n  schema: \"public\"\n};\nvar DEFAULT_AUTH_OPTIONS = {\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true\n};\nvar DEFAULT_REALTIME_OPTIONS = {};\nvar SupabaseClient = class {\n  constructor(supabaseUrl, supabaseKey, options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    this.supabaseUrl = supabaseUrl;\n    this.supabaseKey = supabaseKey;\n    if (!supabaseUrl)\n      throw new Error(\"supabaseUrl is required.\");\n    if (!supabaseKey)\n      throw new Error(\"supabaseKey is required.\");\n    const _supabaseUrl = stripTrailingSlash(supabaseUrl);\n    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, \"ws\");\n    this.authUrl = `${_supabaseUrl}/auth/v1`;\n    this.storageUrl = `${_supabaseUrl}/storage/v1`;\n    const isPlatform = _supabaseUrl.match(/(supabase\\.co)|(supabase\\.in)/);\n    if (isPlatform) {\n      const urlParts = _supabaseUrl.split(\".\");\n      this.functionsUrl = `${urlParts[0]}.functions.${urlParts[1]}.${urlParts[2]}`;\n    } else {\n      this.functionsUrl = `${_supabaseUrl}/functions/v1`;\n    }\n    const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split(\".\")[0]}-auth-token`;\n    const DEFAULTS = {\n      db: DEFAULT_DB_OPTIONS,\n      realtime: DEFAULT_REALTIME_OPTIONS,\n      auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), { storageKey: defaultStorageKey }),\n      global: DEFAULT_GLOBAL_OPTIONS\n    };\n    const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);\n    this.storageKey = (_b = (_a = settings.auth) === null || _a === void 0 ? void 0 : _a.storageKey) !== null && _b !== void 0 ? _b : \"\";\n    this.headers = (_d = (_c = settings.global) === null || _c === void 0 ? void 0 : _c.headers) !== null && _d !== void 0 ? _d : {};\n    this.auth = this._initSupabaseAuthClient((_e = settings.auth) !== null && _e !== void 0 ? _e : {}, this.headers, (_f = settings.global) === null || _f === void 0 ? void 0 : _f.fetch);\n    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), (_g = settings.global) === null || _g === void 0 ? void 0 : _g.fetch);\n    this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers }, settings.realtime));\n    this.rest = new PostgrestClient(`${_supabaseUrl}/rest/v1`, {\n      headers: this.headers,\n      schema: (_h = settings.db) === null || _h === void 0 ? void 0 : _h.schema,\n      fetch: this.fetch\n    });\n    this._listenForAuthEvents();\n  }\n  get functions() {\n    return new FunctionsClient(this.functionsUrl, {\n      headers: this.headers,\n      customFetch: this.fetch\n    });\n  }\n  get storage() {\n    return new StorageClient(this.storageUrl, this.headers, this.fetch);\n  }\n  from(relation) {\n    return this.rest.from(relation);\n  }\n  rpc(fn, args = {}, options) {\n    return this.rest.rpc(fn, args, options);\n  }\n  channel(name, opts = { config: {} }) {\n    return this.realtime.channel(name, opts);\n  }\n  getChannels() {\n    return this.realtime.getChannels();\n  }\n  removeChannel(channel) {\n    return this.realtime.removeChannel(channel);\n  }\n  removeAllChannels() {\n    return this.realtime.removeAllChannels();\n  }\n  _getAccessToken() {\n    var _a, _b;\n    return __awaiter15(this, void 0, void 0, function* () {\n      const { data } = yield this.auth.getSession();\n      return (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : null;\n    });\n  }\n  _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, storageKey }, headers, fetch2) {\n    const authHeaders = {\n      Authorization: `Bearer ${this.supabaseKey}`,\n      apikey: `${this.supabaseKey}`\n    };\n    return new SupabaseAuthClient({\n      url: this.authUrl,\n      headers: Object.assign(Object.assign({}, authHeaders), headers),\n      storageKey,\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      fetch: fetch2\n    });\n  }\n  _initRealtimeClient(options) {\n    return new RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), { params: Object.assign({ apikey: this.supabaseKey }, options === null || options === void 0 ? void 0 : options.params) }));\n  }\n  _listenForAuthEvents() {\n    let data = this.auth.onAuthStateChange((event, session) => {\n      this._handleTokenChanged(event, session === null || session === void 0 ? void 0 : session.access_token, \"CLIENT\");\n    });\n    return data;\n  }\n  _handleTokenChanged(event, token, source) {\n    if ((event === \"TOKEN_REFRESHED\" || event === \"SIGNED_IN\") && this.changedAccessToken !== token) {\n      this.realtime.setAuth(token !== null && token !== void 0 ? token : null);\n      this.changedAccessToken = token;\n    } else if (event === \"SIGNED_OUT\" || event === \"USER_DELETED\") {\n      this.realtime.setAuth(this.supabaseKey);\n      if (source == \"STORAGE\")\n        this.auth.signOut();\n    }\n  }\n};\n\n// node_modules/.pnpm/@supabase+supabase-js@2.1.0/node_modules/@supabase/supabase-js/dist/module/index.js\nvar createClient = (supabaseUrl, supabaseKey, options) => {\n  return new SupabaseClient(supabaseUrl, supabaseKey, options);\n};\nexport {\n  AuthApiError,\n  AuthError,\n  AuthImplicitGrantRedirectError,\n  AuthInvalidCredentialsError,\n  AuthRetryableFetchError,\n  AuthSessionMissingError,\n  AuthUnknownError,\n  CustomAuthError,\n  FunctionsError,\n  FunctionsFetchError,\n  FunctionsHttpError,\n  FunctionsRelayError,\n  GoTrueAdminApi,\n  GoTrueClient,\n  REALTIME_LISTEN_TYPES,\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT,\n  REALTIME_PRESENCE_LISTEN_EVENTS,\n  REALTIME_SUBSCRIBE_STATES,\n  RealtimeChannel,\n  RealtimeClient,\n  RealtimePresence,\n  SupabaseClient,\n  createClient,\n  isAuthError\n};\n//# sourceMappingURL=@supabase_supabase-js.js.map\n",
      "start": 1681505639048,
      "end": 1681505639051
    }
  ],
  "virtual": true
}